"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/gameStore.ts":
/*!********************************!*\
  !*** ./src/store/gameStore.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameStore: () => (/* binding */ useGameStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n\nconst initialTree = {\n    id: 'root',\n    name: 'Start',\n    value: 0,\n    children: [\n        {\n            id: 'A',\n            name: 'A',\n            value: 5,\n            children: [],\n            costToParent: 1\n        },\n        {\n            id: 'B',\n            name: 'B',\n            value: 3,\n            children: [],\n            costToParent: 2\n        }\n    ]\n};\nconst useGameStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set)=>({\n        algorithm: null,\n        problemType: 'custom',\n        depth: 0,\n        nodesExplored: 0,\n        isSimulating: false,\n        resetTrigger: 0,\n        tree: initialTree,\n        admissibilityViolations: [],\n        goalState: [\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            0\n        ],\n        // Default visual settings\n        maxNodeShape: 'triangle',\n        minNodeShape: 'circle',\n        nodeViewMode: 'shape',\n        setAlgorithm: (algo)=>set({\n                algorithm: algo,\n                admissibilityViolations: []\n            }),\n        setProblemType: (type)=>set((state)=>{\n                // Reseta o estado objetivo ao mudar de problema\n                const newGoalState = type === 'tictactoe' ? Array(9).fill(null) : [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7,\n                    8,\n                    0\n                ];\n                return {\n                    problemType: type,\n                    resetTrigger: state.resetTrigger + 1,\n                    goalState: newGoalState\n                };\n            }),\n        setDepth: (depth)=>set({\n                depth\n            }),\n        incrementNodes: ()=>set((state)=>({\n                    nodesExplored: state.nodesExplored + 1\n                })),\n        toggleSimulation: ()=>set((state)=>({\n                    isSimulating: !state.isSimulating\n                })),\n        reset: ()=>set((state)=>({\n                    depth: 0,\n                    nodesExplored: 0,\n                    isSimulating: false,\n                    resetTrigger: state.resetTrigger + 1,\n                    admissibilityViolations: []\n                })),\n        setNodesExplored: (count)=>set({\n                nodesExplored: count\n            }),\n        setMaxNodeShape: (shape)=>set({\n                maxNodeShape: shape\n            }),\n        setMinNodeShape: (shape)=>set({\n                minNodeShape: shape\n            }),\n        setNodeViewMode: (mode)=>set({\n                nodeViewMode: mode\n            }),\n        setGoalState: (state)=>set({\n                goalState: state\n            }),\n        setAdmissibilityViolations: (ids)=>set({\n                admissibilityViolations: ids\n            }),\n        updateTree: (newTree)=>set({\n                tree: newTree\n            }),\n        addNode: (parentId, newNode)=>set((state)=>{\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const addRecursive = (node)=>{\n                    if (node.id === parentId) {\n                        node.children.push(newNode);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (addRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                addRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            }),\n        removeNode: (nodeId)=>set((state)=>{\n                if (nodeId === 'root') return state;\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const removeRecursive = (node)=>{\n                    const index = node.children.findIndex((c)=>c.id === nodeId);\n                    if (index !== -1) {\n                        node.children.splice(index, 1);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (removeRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                removeRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            }),\n        updateNodeAttributes: (nodeId, attributes)=>set((state)=>{\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const updateRecursive = (node)=>{\n                    if (node.id === nodeId) {\n                        Object.assign(node, attributes);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (updateRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                updateRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            })\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9nYW1lU3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0M7QUFtRWhDLE1BQU1DLGNBQThCO0lBQ2xDQyxJQUFJO0lBQ0pDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxVQUFVO1FBQ1I7WUFBRUgsSUFBSTtZQUFLQyxNQUFNO1lBQUtDLE9BQU87WUFBR0MsVUFBVSxFQUFFO1lBQUVDLGNBQWM7UUFBRTtRQUM5RDtZQUFFSixJQUFJO1lBQUtDLE1BQU07WUFBS0MsT0FBTztZQUFHQyxVQUFVLEVBQUU7WUFBRUMsY0FBYztRQUFFO0tBQy9EO0FBQ0g7QUFFTyxNQUFNQyxlQUFlUCwrQ0FBTUEsQ0FBWSxDQUFDUSxNQUFTO1FBQ3REQyxXQUFXO1FBQ1hDLGFBQWE7UUFDYkMsT0FBTztRQUNQQyxlQUFlO1FBQ2ZDLGNBQWM7UUFDZEMsY0FBYztRQUNkQyxNQUFNZDtRQUNOZSx5QkFBeUIsRUFBRTtRQUMzQkMsV0FBVztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBRXRDLDBCQUEwQjtRQUMxQkMsY0FBYztRQUNkQyxjQUFjO1FBQ2RDLGNBQWM7UUFFZEMsY0FBYyxDQUFDQyxPQUFTZCxJQUFJO2dCQUFFQyxXQUFXYTtnQkFBTU4seUJBQXlCLEVBQUU7WUFBQztRQUMzRU8sZ0JBQWdCLENBQUNDLE9BQVNoQixJQUFJLENBQUNpQjtnQkFDN0IsZ0RBQWdEO2dCQUNoRCxNQUFNQyxlQUFlRixTQUFTLGNBQWNHLE1BQU0sR0FBR0MsSUFBSSxDQUFDLFFBQVE7b0JBQUM7b0JBQUc7b0JBQUc7b0JBQUc7b0JBQUc7b0JBQUc7b0JBQUc7b0JBQUc7b0JBQUc7aUJBQUU7Z0JBQzdGLE9BQU87b0JBQUVsQixhQUFhYztvQkFBTVYsY0FBY1csTUFBTVgsWUFBWSxHQUFHO29CQUFHRyxXQUFXUztnQkFBYTtZQUM1RjtRQUNBRyxVQUFVLENBQUNsQixRQUFVSCxJQUFJO2dCQUFF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T0FBTztnQkFDVDtnQkFDQVUsZ0JBQWdCcEI7Z0JBQ2hCLE9BQU87b0JBQUU3QixNQUFNNkI7Z0JBQVE7WUFDekI7SUFDRixJQUFHIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGJyYW5kXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcR2l0SHViXFxhbGdvcml0aG1fSUFcXHNyY1xcc3RvcmVcXGdhbWVTdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJ1xyXG5cclxuZXhwb3J0IHR5cGUgQWxnb3JpdGhtVHlwZSA9XHJcbiAgfCAnYmZzJyB8ICdkZnMnIHwgJ2lkcycgfCAndWNzJyB8ICdncmVlZHknIHwgJ2FzdGFyJyB8ICdpZGFzdGFyJ1xyXG4gIHwgJ21pbmltYXgnIHwgJ2FscGhhLWJldGEnIHwgJ21jdHMnXHJcbiAgfCBudWxsO1xyXG5cclxuZXhwb3J0IHR5cGUgUHJvYmxlbVR5cGUgPSAnY3VzdG9tJyB8ICd0aWN0YWN0b2UnIHwgJzhwdXp6bGUnO1xyXG5cclxuZXhwb3J0IHR5cGUgTm9kZVNoYXBlID0gJ2NpcmNsZScgfCAndHJpYW5nbGUnIHwgJ3NxdWFyZSc7XHJcblxyXG5leHBvcnQgdHlwZSBOb2RlVmlld01vZGUgPSAnc2hhcGUnIHwgJ2dhbWUnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21UcmVlTm9kZSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgdmFsdWU/OiBudW1iZXI7IC8vIEhldXLDrXN0aWNhIG91IFV0aWxpZGFkZVxyXG4gIGNoaWxkcmVuOiBDdXN0b21UcmVlTm9kZVtdO1xyXG4gIGlzR29hbD86IGJvb2xlYW47XHJcbiAgY29zdFRvUGFyZW50PzogbnVtYmVyOyAvLyBDdXN0byBkYSBhcmVzdGFcclxuICBib2FyZFN0YXRlPzogYW55OyAvLyBQYXJhIFRpY1RhY1RvZSBvdSA4LVB1enpsZVxyXG59XHJcblxyXG5pbnRlcmZhY2UgR2FtZVN0YXRlIHtcclxuICBhbGdvcml0aG06IEFsZ29yaXRobVR5cGVcclxuICBwcm9ibGVtVHlwZTogUHJvYmxlbVR5cGVcclxuICBkZXB0aDogbnVtYmVyXHJcbiAgbm9kZXNFeHBsb3JlZDogbnVtYmVyXHJcbiAgaXNTaW11bGF0aW5nOiBib29sZWFuXHJcbiAgcmVzZXRUcmlnZ2VyOiBudW1iZXJcclxuXHJcbiAgLy8gQ29uZmlndXJhw6fDtWVzIFZpc3VhaXNcclxuICBtYXhOb2RlU2hhcGU6IE5vZGVTaGFwZVxyXG4gIG1pbk5vZGVTaGFwZTogTm9kZVNoYXBlXHJcbiAgbm9kZVZpZXdNb2RlOiBOb2RlVmlld01vZGVcclxuICBnb2FsU3RhdGU6IGFueSB8IG51bGwgLy8gTm92bzogcGFyYSBndWFyZGFyIG8gZXN0YWRvIG9iamV0aXZvIGdsb2JhbFxyXG5cclxuICAvLyBJRHMgZGUgbsOzcyBxdWUgdmlvbGFtIGEgYWRtaXNzaWJpbGlkYWRlXHJcbiAgYWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IHN0cmluZ1tdXHJcblxyXG4gIC8vIEVzdGFkbyBkYSDDgXJ2b3JlIEN1c3RvbWl6YWRhXHJcbiAgdHJlZTogQ3VzdG9tVHJlZU5vZGVcclxuXHJcbiAgc2V0QWxnb3JpdGhtOiAoYWxnbzogQWxnb3JpdGhtVHlwZSkgPT4gdm9pZFxyXG4gIHNldFByb2JsZW1UeXBlOiAodHlwZTogUHJvYmxlbVR5cGUpID0+IHZvaWRcclxuICBzZXREZXB0aDogKGRlcHRoOiBudW1iZXIpID0+IHZvaWRcclxuICBpbmNyZW1lbnROb2RlczogKCkgPT4gdm9pZFxyXG4gIHRvZ2dsZVNpbXVsYXRpb246ICgpID0+IHZvaWRcclxuICByZXNldDogKCkgPT4gdm9pZFxyXG4gIFxyXG4gIC8vIEHDp8O1ZXMgVmlzdWFpc1xyXG4gIHNldE1heE5vZGVTaGFwZTogKHNoYXBlOiBOb2RlU2hhcGUpID0+IHZvaWRcclxuICBzZXRNaW5Ob2RlU2hhcGU6IChzaGFwZTogTm9kZVNoYXBlKSA9PiB2b2lkXHJcbiAgc2V0Tm9kZVZpZXdNb2RlOiAobW9kZTogTm9kZVZpZXdNb2RlKSA9PiB2b2lkXHJcbiAgc2V0R29hbFN0YXRlOiAoc3RhdGU6IGFueSkgPT4gdm9pZFxyXG5cclxuICAvLyBBw6fDtWVzIGRlIEFkbWlzc2liaWxpZGFkZVxyXG4gIHNldEFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiAoaWRzOiBzdHJpbmdbXSkgPT4gdm9pZFxyXG5cclxuICAvLyBBw6fDtWVzIGRlIEVkacOnw6NvIGRhIMOBcnZvcmVcclxuICB1cGRhdGVUcmVlOiAobmV3VHJlZTogQ3VzdG9tVHJlZU5vZGUpID0+IHZvaWRcclxuICBhZGROb2RlOiAocGFyZW50SWQ6IHN0cmluZywgbm9kZTogQ3VzdG9tVHJlZU5vZGUpID0+IHZvaWRcclxuICByZW1vdmVOb2RlOiAobm9kZUlkOiBzdHJpbmcpID0+IHZvaWRcclxuICB1cGRhdGVOb2RlQXR0cmlidXRlczogKG5vZGVJZDogc3RyaW5nLCBhdHRyaWJ1dGVzOiBQYXJ0aWFsPEN1c3RvbVRyZWVOb2RlPikgPT4gdm9pZFxyXG4gIHNldE5vZGVzRXhwbG9yZWQ6IChjb3VudDogbnVtYmVyKSA9PiB2b2lkXHJcbn1cclxuXHJcbmNvbnN0IGluaXRpYWxUcmVlOiBDdXN0b21UcmVlTm9kZSA9IHtcclxuICBpZDogJ3Jvb3QnLFxyXG4gIG5hbWU6ICdTdGFydCcsXHJcbiAgdmFsdWU6IDAsXHJcbiAgY2hpbGRyZW46IFtcclxuICAgIHsgaWQ6ICdBJywgbmFtZTogJ0EnLCB2YWx1ZTogNSwgY2hpbGRyZW46IFtdLCBjb3N0VG9QYXJlbnQ6IDEgfSxcclxuICAgIHsgaWQ6ICdCJywgbmFtZTogJ0InLCB2YWx1ZTogMywgY2hpbGRyZW46IFtdLCBjb3N0VG9QYXJlbnQ6IDIgfVxyXG4gIF1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VHYW1lU3RvcmUgPSBjcmVhdGU8R2FtZVN0YXRlPigoc2V0KSA9PiAoe1xyXG4gIGFsZ29yaXRobTogbnVsbCxcclxuICBwcm9ibGVtVHlwZTogJ2N1c3RvbScsXHJcbiAgZGVwdGg6IDAsXHJcbiAgbm9kZXNFeHBsb3JlZDogMCxcclxuICBpc1NpbXVsYXRpbmc6IGZhbHNlLFxyXG4gIHJlc2V0VHJpZ2dlcjogMCxcclxuICB0cmVlOiBpbml0aWFsVHJlZSxcclxuICBhZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogW10sXHJcbiAgZ29hbFN0YXRlOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgMF0sIC8vIEVzdGFkbyBvYmpldGl2byBwYWRyw6NvIHBhcmEgOC1QdXp6bGVcclxuXHJcbiAgLy8gRGVmYXVsdCB2aXN1YWwgc2V0dGluZ3NcclxuICBtYXhOb2RlU2hhcGU6ICd0cmlhbmdsZScsXHJcbiAgbWluTm9kZVNoYXBlOiAnY2lyY2xlJyxcclxuICBub2RlVmlld01vZGU6ICdzaGFwZScsXHJcblxyXG4gIHNldEFsZ29yaXRobTogKGFsZ28pID0+IHNldCh7IGFsZ29yaXRobTogYWxnbywgYWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IFtdIH0pLFxyXG4gIHNldFByb2JsZW1UeXBlOiAodHlwZSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgLy8gUmVzZXRhIG8gZXN0YWRvIG9iamV0aXZvIGFvIG11ZGFyIGRlIHByb2JsZW1hXHJcbiAgICBjb25zdCBuZXdHb2FsU3RhdGUgPSB0eXBlID09PSAndGljdGFjdG9lJyA/IEFycmF5KDkpLmZpbGwobnVsbCkgOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgMF07XHJcbiAgICByZXR1cm4geyBwcm9ibGVtVHlwZTogdHlwZSwgcmVzZXRUcmlnZ2VyOiBzdGF0ZS5yZXNldFRyaWdnZXIgKyAxLCBnb2FsU3RhdGU6IG5ld0dvYWxTdGF0ZSB9O1xyXG4gIH0pLFxyXG4gIHNldERlcHRoOiAoZGVwdGgpID0+IHNldCh7IGRlcHRoIH0pLFxyXG4gIGluY3JlbWVudE5vZGVzOiAoKSA9PiBzZXQoKHN0YXRlKSA9PiAoeyBub2Rlc0V4cGxvcmVkOiBzdGF0ZS5ub2Rlc0V4cGxvcmVkICsgMSB9KSksXHJcbiAgdG9nZ2xlU2ltdWxhdGlvbjogKCkgPT4gc2V0KChzdGF0ZSkgPT4gKHsgaXNTaW11bGF0aW5nOiAhc3RhdGUuaXNTaW11bGF0aW5nIH0pKSxcclxuICBcclxuICByZXNldDogKCkgPT4gc2V0KChzdGF0ZSkgPT4gKHsgXHJcbiAgICBkZXB0aDogMCwgXHJcbiAgICBub2Rlc0V4cGxvcmVkOiAwLCBcclxuICAgIGlzU2ltdWxhdGluZzogZmFsc2UsXHJcbiAgICByZXNldFRyaWdnZXI6IHN0YXRlLnJlc2V0VHJpZ2dlciArIDEsXHJcbiAgICBhZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogW11cclxuICB9KSksXHJcbiAgXHJcbiAgc2V0Tm9kZXNFeHBsb3JlZDogKGNvdW50KSA9PiBzZXQoeyBub2Rlc0V4cGxvcmVkOiBjb3VudCB9KSxcclxuXHJcbiAgc2V0TWF4Tm9kZVNoYXBlOiAoc2hhcGUpID0+IHNldCh7IG1heE5vZGVTaGFwZTogc2hhcGUgfSksXHJcbiAgc2V0TWluTm9kZVNoYXBlOiAoc2hhcGUpID0+IHNldCh7IG1pbk5vZGVTaGFwZTogc2hhcGUgfSksXHJcbiAgc2V0Tm9kZVZpZXdNb2RlOiAobW9kZSkgPT4gc2V0KHsgbm9kZVZpZXdNb2RlOiBtb2RlIH0pLFxyXG4gIHNldEdvYWxTdGF0ZTogKHN0YXRlKSA9PiBzZXQoeyBnb2FsU3RhdGU6IHN0YXRlIH0pLFxyXG5cclxuICBzZXRBZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogKGlkcykgPT4gc2V0KHsgYWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IGlkcyB9KSxcclxuXHJcbiAgdXBkYXRlVHJlZTogKG5ld1RyZWUpID0+IHNldCh7IHRyZWU6IG5ld1RyZWUgfSksXHJcblxyXG4gIGFkZE5vZGU6IChwYXJlbnRJZCwgbmV3Tm9kZSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSkpO1xyXG4gICAgY29uc3QgYWRkUmVjdXJzaXZlID0gKG5vZGU6IEN1c3RvbVRyZWVOb2RlKSA9PiB7XHJcbiAgICAgIGlmIChub2RlLmlkID09PSBwYXJlbnRJZCkge1xyXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAoYWRkUmVjdXJzaXZlKGNoaWxkKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIGFkZFJlY3Vyc2l2ZShuZXdUcmVlKTtcclxuICAgIHJldHVybiB7IHRyZWU6IG5ld1RyZWUgfTtcclxuICB9KSxcclxuXHJcbiAgcmVtb3ZlTm9kZTogKG5vZGVJZCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgaWYgKG5vZGVJZCA9PT0gJ3Jvb3QnKSByZXR1cm4gc3RhdGU7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKSk7XHJcbiAgICBjb25zdCByZW1vdmVSZWN1cnNpdmUgPSAobm9kZTogQ3VzdG9tVHJlZU5vZGUpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSBub2RlLmNoaWxkcmVuLmZpbmRJbmRleChjID0+IGMuaWQgPT09IG5vZGVJZCk7XHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKHJlbW92ZVJlY3Vyc2l2ZShjaGlsZCkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZW1vdmVSZWN1cnNpdmUobmV3VHJlZSk7XHJcbiAgICByZXR1cm4geyB0cmVlOiBuZXdUcmVlIH07XHJcbiAgfSksXHJcblxyXG4gIHVwZGF0ZU5vZGVBdHRyaWJ1dGVzOiAobm9kZUlkLCBhdHRyaWJ1dGVzKSA9PiBzZXQoKHN0YXRlKSA9PiB7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKSk7XHJcbiAgICBjb25zdCB1cGRhdGVSZWN1cnNpdmUgPSAobm9kZTogQ3VzdG9tVHJlZU5vZGUpID0+IHtcclxuICAgICAgaWYgKG5vZGUuaWQgPT09IG5vZGVJZCkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24obm9kZSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKHVwZGF0ZVJlY3Vyc2l2ZShjaGlsZCkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICB1cGRhdGVSZWN1cnNpdmUobmV3VHJlZSk7XHJcbiAgICByZXR1cm4geyB0cmVlOiBuZXdUcmVlIH07XHJcbiAgfSlcclxufSkpXHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJpbml0aWFsVHJlZSIsImlkIiwibmFtZSIsInZhbHVlIiwiY2hpbGRyZW4iLCJjb3N0VG9QYXJlbnQiLCJ1c2VHYW1lU3RvcmUiLCJzZXQiLCJhbGdvcml0aG0iLCJwcm9ibGVtVHlwZSIsImRlcHRoIiwibm9kZXNFeHBsb3JlZCIsImlzU2ltdWxhdGluZyIsInJlc2V0VHJpZ2dlciIsInRyZWUiLCJhZG1pc3NpYmlsaXR5VmlvbGF0aW9ucyIsImdvYWxTdGF0ZSIsIm1heE5vZGVTaGFwZSIsIm1pbk5vZGVTaGFwZSIsIm5vZGVWaWV3TW9kZSIsInNldEFsZ29yaXRobSIsImFsZ28iLCJzZXRQcm9ibGVtVHlwZSIsInR5cGUiLCJzdGF0ZSIsIm5ld0dvYWxTdGF0ZSIsIkFycmF5IiwiZmlsbCIsInNldERlcHRoIiwiaW5jcmVtZW50Tm9kZXMiLCJ0b2dnbGVTaW11bGF0aW9uIiwicmVzZXQiLCJzZXROb2Rlc0V4cGxvcmVkIiwiY291bnQiLCJzZXRNYXhOb2RlU2hhcGUiLCJzaGFwZSIsInNldE1pbk5vZGVTaGFwZSIsInNldE5vZGVWaWV3TW9kZSIsIm1vZGUiLCJzZXRHb2FsU3RhdGUiLCJzZXRBZG1pc3NpYmlsaXR5VmlvbGF0aW9ucyIsImlkcyIsInVwZGF0ZVRyZWUiLCJuZXdUcmVlIiwiYWRkTm9kZSIsInBhcmVudElkIiwibmV3Tm9kZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImFkZFJlY3Vyc2l2ZSIsIm5vZGUiLCJwdXNoIiwiY2hpbGQiLCJyZW1vdmVOb2RlIiwibm9kZUlkIiwicmVtb3ZlUmVjdXJzaXZlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJjIiwic3BsaWNlIiwidXBkYXRlTm9kZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwidXBkYXRlUmVjdXJzaXZlIiwiT2JqZWN0IiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/gameStore.ts\n"));

/***/ })

});