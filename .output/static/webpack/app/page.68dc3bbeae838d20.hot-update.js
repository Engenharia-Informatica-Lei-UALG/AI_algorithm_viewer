"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/gameStore.ts":
/*!********************************!*\
  !*** ./src/store/gameStore.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameStore: () => (/* binding */ useGameStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n\nconst initialTree = {\n    id: 'root',\n    name: 'Start',\n    value: 0,\n    children: [\n        {\n            id: 'A',\n            name: 'A',\n            value: 5,\n            children: [],\n            costToParent: 1\n        },\n        {\n            id: 'B',\n            name: 'B',\n            value: 3,\n            children: [],\n            costToParent: 2\n        }\n    ]\n};\nconst useGameStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set)=>({\n        algorithm: null,\n        problemType: 'custom',\n        depth: 0,\n        nodesExplored: 0,\n        isSimulating: false,\n        resetTrigger: 0,\n        tree: initialTree,\n        admissibilityViolations: [],\n        goalState: [\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            0\n        ],\n        // Default visual settings\n        maxNodeShape: 'triangle',\n        minNodeShape: 'circle',\n        nodeViewMode: 'shape',\n        setAlgorithm: (algo)=>set({\n                algorithm: algo,\n                admissibilityViolations: []\n            }),\n        setProblemType: (type)=>set((state)=>{\n                const newGoalState = type === 'tictactoe' ? Array(9).fill(null) : [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7,\n                    8,\n                    0\n                ];\n                // Lógica automática de visualização\n                const newNodeViewMode = type === 'custom' ? 'shape' : 'game';\n                return {\n                    problemType: type,\n                    resetTrigger: state.resetTrigger + 1,\n                    goalState: newGoalState,\n                    nodeViewMode: newNodeViewMode\n                };\n            }),\n        setDepth: (depth)=>set({\n                depth\n            }),\n        incrementNodes: ()=>set((state)=>({\n                    nodesExplored: state.nodesExplored + 1\n                })),\n        toggleSimulation: ()=>set((state)=>({\n                    isSimulating: !state.isSimulating\n                })),\n        reset: ()=>set((state)=>({\n                    depth: 0,\n                    nodesExplored: 0,\n                    isSimulating: false,\n                    resetTrigger: state.resetTrigger + 1,\n                    admissibilityViolations: []\n                })),\n        setNodesExplored: (count)=>set({\n                nodesExplored: count\n            }),\n        setMaxNodeShape: (shape)=>set({\n                maxNodeShape: shape\n            }),\n        setMinNodeShape: (shape)=>set({\n                minNodeShape: shape\n            }),\n        setNodeViewMode: (mode)=>set({\n                nodeViewMode: mode\n            }),\n        setGoalState: (state)=>set({\n                goalState: state\n            }),\n        setAdmissibilityViolations: (ids)=>set({\n                admissibilityViolations: ids\n            }),\n        updateTree: (newTree)=>set({\n                tree: newTree\n            }),\n        addNode: (parentId, newNode)=>set((state)=>{\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const addRecursive = (node)=>{\n                    if (node.id === parentId) {\n                        node.children.push(newNode);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (addRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                addRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            }),\n        removeNode: (nodeId)=>set((state)=>{\n                if (nodeId === 'root') return state;\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const removeRecursive = (node)=>{\n                    const index = node.children.findIndex((c)=>c.id === nodeId);\n                    if (index !== -1) {\n                        node.children.splice(index, 1);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (removeRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                removeRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            }),\n        updateNodeAttributes: (nodeId, attributes)=>set((state)=>{\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const updateRecursive = (node)=>{\n                    if (node.id === nodeId) {\n                        Object.assign(node, attributes);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (updateRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                updateRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            })\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9nYW1lU3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0M7QUFtRWhDLE1BQU1DLGNBQThCO0lBQ2xDQyxJQUFJO0lBQ0pDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxVQUFVO1FBQ1I7WUFBRUgsSUFBSTtZQUFLQyxNQUFNO1lBQUtDLE9BQU87WUFBR0MsVUFBVSxFQUFFO1lBQUVDLGNBQWM7UUFBRTtRQUM5RDtZQUFFSixJQUFJO1lBQUtDLE1BQU07WUFBS0MsT0FBTztZQUFHQyxVQUFVLEVBQUU7WUFBRUMsY0FBYztRQUFFO0tBQy9EO0FBQ0g7QUFFTyxNQUFNQyxlQUFlUCwrQ0FBTUEsQ0FBWSxDQUFDUSxNQUFTO1FBQ3REQyxXQUFXO1FBQ1hDLGFBQWE7UUFDYkMsT0FBTztRQUNQQyxlQUFlO1FBQ2ZDLGNBQWM7UUFDZEMsY0FBYztRQUNkQyxNQUFNZDtRQUNOZSx5QkFBeUIsRUFBRTtRQUMzQkMsV0FBVztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBRXRDLDBCQUEwQjtRQUMxQkMsY0FBYztRQUNkQyxjQUFjO1FBQ2RDLGNBQWM7UUFFZEMsY0FBYyxDQUFDQyxPQUFTZCxJQUFJO2dCQUFFQyxXQUFXYTtnQkFBTU4seUJBQXlCLEVBQUU7WUFBQztRQUMzRU8sZ0JBQWdCLENBQUNDLE9BQVNoQixJQUFJLENBQUNpQjtnQkFDN0IsTUFBTUMsZUFBZUYsU0FBUyxjQUFjRyxNQUFNLEdBQUdDLElBQUksQ0FBQyxRQUFRO29CQUFDO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO2lCQUFFO2dCQUM3RixvQ0FBb0M7Z0JBQ3BDLE1BQU1DLGtCQUFrQkwsU0FBUyxXQUFXLFVBQVU7Z0JBRXRELE9BQU87b0JBQ0xkLGFBQWFjO29CQUNiVixjQUFjVyxNQUFNWCxZQUFZLEdBQUc7b0JBQ25DRyxXQUFXUztvQkFDWE4sY0FB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Q0FBRTt3QkFDakMsSUFBSTRELGdCQUFnQlYsUUFBUSxPQUFPO29CQUNyQztvQkFDQSxPQUFPO2dCQUNUO2dCQUNBVSxnQkFBZ0JwQjtnQkFDaEIsT0FBTztvQkFBRTlCLE1BQU04QjtnQkFBUTtZQUN6QjtJQUNGLElBQUciLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYnJhbmRcXE9uZURyaXZlXFxEb2N1bWVudG9zXFxHaXRIdWJcXGFsZ29yaXRobV9JQVxcc3JjXFxzdG9yZVxcZ2FtZVN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnXHJcblxyXG5leHBvcnQgdHlwZSBBbGdvcml0aG1UeXBlID1cclxuICB8ICdiZnMnIHwgJ2RmcycgfCAnaWRzJyB8ICd1Y3MnIHwgJ2dyZWVkeScgfCAnYXN0YXInIHwgJ2lkYXN0YXInXHJcbiAgfCAnbWluaW1heCcgfCAnYWxwaGEtYmV0YScgfCAnbWN0cydcclxuICB8IG51bGw7XHJcblxyXG5leHBvcnQgdHlwZSBQcm9ibGVtVHlwZSA9ICdjdXN0b20nIHwgJ3RpY3RhY3RvZScgfCAnOHB1enpsZSc7XHJcblxyXG5leHBvcnQgdHlwZSBOb2RlU2hhcGUgPSAnY2lyY2xlJyB8ICd0cmlhbmdsZScgfCAnc3F1YXJlJztcclxuXHJcbmV4cG9ydCB0eXBlIE5vZGVWaWV3TW9kZSA9ICdzaGFwZScgfCAnZ2FtZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVRyZWVOb2RlIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICB2YWx1ZT86IG51bWJlcjsgLy8gSGV1csOtc3RpY2Egb3UgVXRpbGlkYWRlXHJcbiAgY2hpbGRyZW46IEN1c3RvbVRyZWVOb2RlW107XHJcbiAgaXNHb2FsPzogYm9vbGVhbjtcclxuICBjb3N0VG9QYXJlbnQ/OiBudW1iZXI7IC8vIEN1c3RvIGRhIGFyZXN0YVxyXG4gIGJvYXJkU3RhdGU/OiBhbnk7IC8vIFBhcmEgVGljVGFjVG9lIG91IDgtUHV6emxlXHJcbn1cclxuXHJcbmludGVyZmFjZSBHYW1lU3RhdGUge1xyXG4gIGFsZ29yaXRobTogQWxnb3JpdGhtVHlwZVxyXG4gIHByb2JsZW1UeXBlOiBQcm9ibGVtVHlwZVxyXG4gIGRlcHRoOiBudW1iZXJcclxuICBub2Rlc0V4cGxvcmVkOiBudW1iZXJcclxuICBpc1NpbXVsYXRpbmc6IGJvb2xlYW5cclxuICByZXNldFRyaWdnZXI6IG51bWJlclxyXG5cclxuICAvLyBDb25maWd1cmHDp8O1ZXMgVmlzdWFpc1xyXG4gIG1heE5vZGVTaGFwZTogTm9kZVNoYXBlXHJcbiAgbWluTm9kZVNoYXBlOiBOb2RlU2hhcGVcclxuICBub2RlVmlld01vZGU6IE5vZGVWaWV3TW9kZVxyXG4gIGdvYWxTdGF0ZTogYW55IHwgbnVsbFxyXG5cclxuICAvLyBJRHMgZGUgbsOzcyBxdWUgdmlvbGFtIGEgYWRtaXNzaWJpbGlkYWRlXHJcbiAgYWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IHN0cmluZ1tdXHJcblxyXG4gIC8vIEVzdGFkbyBkYSDDgXJ2b3JlIEN1c3RvbWl6YWRhXHJcbiAgdHJlZTogQ3VzdG9tVHJlZU5vZGVcclxuXHJcbiAgc2V0QWxnb3JpdGhtOiAoYWxnbzogQWxnb3JpdGhtVHlwZSkgPT4gdm9pZFxyXG4gIHNldFByb2JsZW1UeXBlOiAodHlwZTogUHJvYmxlbVR5cGUpID0+IHZvaWRcclxuICBzZXREZXB0aDogKGRlcHRoOiBudW1iZXIpID0+IHZvaWRcclxuICBpbmNyZW1lbnROb2RlczogKCkgPT4gdm9pZFxyXG4gIHRvZ2dsZVNpbXVsYXRpb246ICgpID0+IHZvaWRcclxuICByZXNldDogKCkgPT4gdm9pZFxyXG4gIFxyXG4gIC8vIEHDp8O1ZXMgVmlzdWFpc1xyXG4gIHNldE1heE5vZGVTaGFwZTogKHNoYXBlOiBOb2RlU2hhcGUpID0+IHZvaWRcclxuICBzZXRNaW5Ob2RlU2hhcGU6IChzaGFwZTogTm9kZVNoYXBlKSA9PiB2b2lkXHJcbiAgc2V0Tm9kZVZpZXdNb2RlOiAobW9kZTogTm9kZVZpZXdNb2RlKSA9PiB2b2lkXHJcbiAgc2V0R29hbFN0YXRlOiAoc3RhdGU6IGFueSkgPT4gdm9pZFxyXG5cclxuICAvLyBBw6fDtWVzIGRlIEFkbWlzc2liaWxpZGFkZVxyXG4gIHNldEFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiAoaWRzOiBzdHJpbmdbXSkgPT4gdm9pZFxyXG5cclxuICAvLyBBw6fDtWVzIGRlIEVkacOnw6NvIGRhIMOBcnZvcmVcclxuICB1cGRhdGVUcmVlOiAobmV3VHJlZTogQ3VzdG9tVHJlZU5vZGUpID0+IHZvaWRcclxuICBhZGROb2RlOiAocGFyZW50SWQ6IHN0cmluZywgbm9kZTogQ3VzdG9tVHJlZU5vZGUpID0+IHZvaWRcclxuICByZW1vdmVOb2RlOiAobm9kZUlkOiBzdHJpbmcpID0+IHZvaWRcclxuICB1cGRhdGVOb2RlQXR0cmlidXRlczogKG5vZGVJZDogc3RyaW5nLCBhdHRyaWJ1dGVzOiBQYXJ0aWFsPEN1c3RvbVRyZWVOb2RlPikgPT4gdm9pZFxyXG4gIHNldE5vZGVzRXhwbG9yZWQ6IChjb3VudDogbnVtYmVyKSA9PiB2b2lkXHJcbn1cclxuXHJcbmNvbnN0IGluaXRpYWxUcmVlOiBDdXN0b21UcmVlTm9kZSA9IHtcclxuICBpZDogJ3Jvb3QnLFxyXG4gIG5hbWU6ICdTdGFydCcsXHJcbiAgdmFsdWU6IDAsXHJcbiAgY2hpbGRyZW46IFtcclxuICAgIHsgaWQ6ICdBJywgbmFtZTogJ0EnLCB2YWx1ZTogNSwgY2hpbGRyZW46IFtdLCBjb3N0VG9QYXJlbnQ6IDEgfSxcclxuICAgIHsgaWQ6ICdCJywgbmFtZTogJ0InLCB2YWx1ZTogMywgY2hpbGRyZW46IFtdLCBjb3N0VG9QYXJlbnQ6IDIgfVxyXG4gIF1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VHYW1lU3RvcmUgPSBjcmVhdGU8R2FtZVN0YXRlPigoc2V0KSA9PiAoe1xyXG4gIGFsZ29yaXRobTogbnVsbCxcclxuICBwcm9ibGVtVHlwZTogJ2N1c3RvbScsXHJcbiAgZGVwdGg6IDAsXHJcbiAgbm9kZXNFeHBsb3JlZDogMCxcclxuICBpc1NpbXVsYXRpbmc6IGZhbHNlLFxyXG4gIHJlc2V0VHJpZ2dlcjogMCxcclxuICB0cmVlOiBpbml0aWFsVHJlZSxcclxuICBhZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogW10sXHJcbiAgZ29hbFN0YXRlOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgMF0sXHJcblxyXG4gIC8vIERlZmF1bHQgdmlzdWFsIHNldHRpbmdzXHJcbiAgbWF4Tm9kZVNoYXBlOiAndHJpYW5nbGUnLFxyXG4gIG1pbk5vZGVTaGFwZTogJ2NpcmNsZScsXHJcbiAgbm9kZVZpZXdNb2RlOiAnc2hhcGUnLFxyXG5cclxuICBzZXRBbGdvcml0aG06IChhbGdvKSA9PiBzZXQoeyBhbGdvcml0aG06IGFsZ28sIGFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiBbXSB9KSxcclxuICBzZXRQcm9ibGVtVHlwZTogKHR5cGUpID0+IHNldCgoc3RhdGUpID0+IHtcclxuICAgIGNvbnN0IG5ld0dvYWxTdGF0ZSA9IHR5cGUgPT09ICd0aWN0YWN0b2UnID8gQXJyYXkoOSkuZmlsbChudWxsKSA6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAwXTtcclxuICAgIC8vIEzDs2dpY2EgYXV0b23DoXRpY2EgZGUgdmlzdWFsaXphw6fDo29cclxuICAgIGNvbnN0IG5ld05vZGVWaWV3TW9kZSA9IHR5cGUgPT09ICdjdXN0b20nID8gJ3NoYXBlJyA6ICdnYW1lJztcclxuICAgIFxyXG4gICAgcmV0dXJuIHsgXHJcbiAgICAgIHByb2JsZW1UeXBlOiB0eXBlLCBcclxuICAgICAgcmVzZXRUcmlnZ2VyOiBzdGF0ZS5yZXNldFRyaWdnZXIgKyAxLCBcclxuICAgICAgZ29hbFN0YXRlOiBuZXdHb2FsU3RhdGUsXHJcbiAgICAgIG5vZGVWaWV3TW9kZTogbmV3Tm9kZVZpZXdNb2RlXHJcbiAgICB9O1xyXG4gIH0pLFxyXG4gIHNldERlcHRoOiAoZGVwdGgpID0+IHNldCh7IGRlcHRoIH0pLFxyXG4gIGluY3JlbWVudE5vZGVzOiAoKSA9PiBzZXQoKHN0YXRlKSA9PiAoeyBub2Rlc0V4cGxvcmVkOiBzdGF0ZS5ub2Rlc0V4cGxvcmVkICsgMSB9KSksXHJcbiAgdG9nZ2xlU2ltdWxhdGlvbjogKCkgPT4gc2V0KChzdGF0ZSkgPT4gKHsgaXNTaW11bGF0aW5nOiAhc3RhdGUuaXNTaW11bGF0aW5nIH0pKSxcclxuICBcclxuICByZXNldDogKCkgPT4gc2V0KChzdGF0ZSkgPT4gKHsgXHJcbiAgICBkZXB0aDogMCwgXHJcbiAgICBub2Rlc0V4cGxvcmVkOiAwLCBcclxuICAgIGlzU2ltdWxhdGluZzogZmFsc2UsXHJcbiAgICByZXNldFRyaWdnZXI6IHN0YXRlLnJlc2V0VHJpZ2dlciArIDEsXHJcbiAgICBhZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogW11cclxuICB9KSksXHJcbiAgXHJcbiAgc2V0Tm9kZXNFeHBsb3JlZDogKGNvdW50KSA9PiBzZXQoeyBub2Rlc0V4cGxvcmVkOiBjb3VudCB9KSxcclxuXHJcbiAgc2V0TWF4Tm9kZVNoYXBlOiAoc2hhcGUpID0+IHNldCh7IG1heE5vZGVTaGFwZTogc2hhcGUgfSksXHJcbiAgc2V0TWluTm9kZVNoYXBlOiAoc2hhcGUpID0+IHNldCh7IG1pbk5vZGVTaGFwZTogc2hhcGUgfSksXHJcbiAgc2V0Tm9kZVZpZXdNb2RlOiAobW9kZSkgPT4gc2V0KHsgbm9kZVZpZXdNb2RlOiBtb2RlIH0pLFxyXG4gIHNldEdvYWxTdGF0ZTogKHN0YXRlKSA9PiBzZXQoeyBnb2FsU3RhdGU6IHN0YXRlIH0pLFxyXG5cclxuICBzZXRBZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogKGlkcykgPT4gc2V0KHsgYWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IGlkcyB9KSxcclxuXHJcbiAgdXBkYXRlVHJlZTogKG5ld1RyZWUpID0+IHNldCh7IHRyZWU6IG5ld1RyZWUgfSksXHJcblxyXG4gIGFkZE5vZGU6IChwYXJlbnRJZCwgbmV3Tm9kZSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSkpO1xyXG4gICAgY29uc3QgYWRkUmVjdXJzaXZlID0gKG5vZGU6IEN1c3RvbVRyZWVOb2RlKSA9PiB7XHJcbiAgICAgIGlmIChub2RlLmlkID09PSBwYXJlbnRJZCkge1xyXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAoYWRkUmVjdXJzaXZlKGNoaWxkKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIGFkZFJlY3Vyc2l2ZShuZXdUcmVlKTtcclxuICAgIHJldHVybiB7IHRyZWU6IG5ld1RyZWUgfTtcclxuICB9KSxcclxuXHJcbiAgcmVtb3ZlTm9kZTogKG5vZGVJZCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgaWYgKG5vZGVJZCA9PT0gJ3Jvb3QnKSByZXR1cm4gc3RhdGU7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKSk7XHJcbiAgICBjb25zdCByZW1vdmVSZWN1cnNpdmUgPSAobm9kZTogQ3VzdG9tVHJlZU5vZGUpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSBub2RlLmNoaWxkcmVuLmZpbmRJbmRleChjID0+IGMuaWQgPT09IG5vZGVJZCk7XHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKHJlbW92ZVJlY3Vyc2l2ZShjaGlsZCkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZW1vdmVSZWN1cnNpdmUobmV3VHJlZSk7XHJcbiAgICByZXR1cm4geyB0cmVlOiBuZXdUcmVlIH07XHJcbiAgfSksXHJcblxyXG4gIHVwZGF0ZU5vZGVBdHRyaWJ1dGVzOiAobm9kZUlkLCBhdHRyaWJ1dGVzKSA9PiBzZXQoKHN0YXRlKSA9PiB7XHJcbiAgICBjb25zdCBuZXdUcmVlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKSk7XHJcbiAgICBjb25zdCB1cGRhdGVSZWN1cnNpdmUgPSAobm9kZTogQ3VzdG9tVHJlZU5vZGUpID0+IHtcclxuICAgICAgaWYgKG5vZGUuaWQgPT09IG5vZGVJZCkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24obm9kZSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKHVwZGF0ZVJlY3Vyc2l2ZShjaGlsZCkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICB1cGRhdGVSZWN1cnNpdmUobmV3VHJlZSk7XHJcbiAgICByZXR1cm4geyB0cmVlOiBuZXdUcmVlIH07XHJcbiAgfSlcclxufSkpXHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJpbml0aWFsVHJlZSIsImlkIiwibmFtZSIsInZhbHVlIiwiY2hpbGRyZW4iLCJjb3N0VG9QYXJlbnQiLCJ1c2VHYW1lU3RvcmUiLCJzZXQiLCJhbGdvcml0aG0iLCJwcm9ibGVtVHlwZSIsImRlcHRoIiwibm9kZXNFeHBsb3JlZCIsImlzU2ltdWxhdGluZyIsInJlc2V0VHJpZ2dlciIsInRyZWUiLCJhZG1pc3NpYmlsaXR5VmlvbGF0aW9ucyIsImdvYWxTdGF0ZSIsIm1heE5vZGVTaGFwZSIsIm1pbk5vZGVTaGFwZSIsIm5vZGVWaWV3TW9kZSIsInNldEFsZ29yaXRobSIsImFsZ28iLCJzZXRQcm9ibGVtVHlwZSIsInR5cGUiLCJzdGF0ZSIsIm5ld0dvYWxTdGF0ZSIsIkFycmF5IiwiZmlsbCIsIm5ld05vZGVWaWV3TW9kZSIsInNldERlcHRoIiwiaW5jcmVtZW50Tm9kZXMiLCJ0b2dnbGVTaW11bGF0aW9uIiwicmVzZXQiLCJzZXROb2Rlc0V4cGxvcmVkIiwiY291bnQiLCJzZXRNYXhOb2RlU2hhcGUiLCJzaGFwZSIsInNldE1pbk5vZGVTaGFwZSIsInNldE5vZGVWaWV3TW9kZSIsIm1vZGUiLCJzZXRHb2FsU3RhdGUiLCJzZXRBZG1pc3NpYmlsaXR5VmlvbGF0aW9ucyIsImlkcyIsInVwZGF0ZVRyZWUiLCJuZXdUcmVlIiwiYWRkTm9kZSIsInBhcmVudElkIiwibmV3Tm9kZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImFkZFJlY3Vyc2l2ZSIsIm5vZGUiLCJwdXNoIiwiY2hpbGQiLCJyZW1vdmVOb2RlIiwibm9kZUlkIiwicmVtb3ZlUmVjdXJzaXZlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJjIiwic3BsaWNlIiwidXBkYXRlTm9kZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwidXBkYXRlUmVjdXJzaXZlIiwiT2JqZWN0IiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/gameStore.ts\n"));

/***/ })

});