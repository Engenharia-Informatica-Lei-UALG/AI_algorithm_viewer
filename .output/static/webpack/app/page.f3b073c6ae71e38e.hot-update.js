"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/gameStore.ts":
/*!********************************!*\
  !*** ./src/store/gameStore.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameStore: () => (/* binding */ useGameStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n\nconst initialTree = {\n    id: 'root',\n    name: 'Start',\n    children: []\n};\nconst useGameStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set)=>({\n        algorithm: null,\n        problemType: 'custom',\n        depth: 0,\n        nodesExplored: 0,\n        isSimulating: false,\n        resetTrigger: 0,\n        tree: initialTree,\n        admissibilityViolations: [],\n        goalState: [\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            0\n        ],\n        // Default settings\n        maxNodeShape: 'triangle',\n        minNodeShape: 'circle',\n        nodeViewMode: 'shape',\n        ticTacToeMaxPlayer: 'X',\n        setAlgorithm: (algo)=>set({\n                algorithm: algo,\n                admissibilityViolations: []\n            }),\n        setProblemType: (type)=>set((state)=>{\n                const newNodeViewMode = type === 'custom' ? 'shape' : 'game';\n                let newTree;\n                let newGoalState;\n                if (type === 'tictactoe') {\n                    newTree = {\n                        id: 'root',\n                        name: 'Start',\n                        children: [],\n                        boardState: Array(9).fill(null)\n                    };\n                    newGoalState = null;\n                } else if (type === '8puzzle') {\n                    newTree = {\n                        id: 'root',\n                        name: 'Start',\n                        children: [],\n                        boardState: [\n                            1,\n                            2,\n                            3,\n                            4,\n                            5,\n                            6,\n                            7,\n                            8,\n                            0\n                        ]\n                    };\n                    newGoalState = [\n                        1,\n                        2,\n                        3,\n                        4,\n                        5,\n                        6,\n                        7,\n                        8,\n                        0\n                    ];\n                } else {\n                    newTree = {\n                        id: 'root',\n                        name: 'Start',\n                        children: []\n                    };\n                    newGoalState = null;\n                }\n                return {\n                    problemType: type,\n                    tree: newTree,\n                    resetTrigger: state.resetTrigger + 1,\n                    goalState: newGoalState,\n                    nodeViewMode: newNodeViewMode,\n                    admissibilityViolations: [],\n                    nodesExplored: 0,\n                    isSimulating: false\n                };\n            }),\n        setDepth: (depth)=>set({\n                depth\n            }),\n        incrementNodes: ()=>set((state)=>({\n                    nodesExplored: state.nodesExplored + 1\n                })),\n        toggleSimulation: ()=>set((state)=>({\n                    isSimulating: !state.isSimulating\n                })),\n        reset: ()=>set((state)=>({\n                    depth: 0,\n                    nodesExplored: 0,\n                    isSimulating: false,\n                    resetTrigger: state.resetTrigger + 1,\n                    admissibilityViolations: []\n                })),\n        setNodesExplored: (count)=>set({\n                nodesExplored: count\n            }),\n        setMaxNodeShape: (shape)=>set({\n                maxNodeShape: shape\n            }),\n        setMinNodeShape: (shape)=>set({\n                minNodeShape: shape\n            }),\n        setNodeViewMode: (mode)=>set({\n                nodeViewMode: mode\n            }),\n        setGoalState: (state)=>set({\n                goalState: state\n            }),\n        setTicTacToeMaxPlayer: (player)=>set({\n                ticTacToeMaxPlayer: player\n            }),\n        setAdmissibilityViolations: (ids)=>set({\n                admissibilityViolations: ids\n            }),\n        updateTree: (newTree)=>set({\n                tree: newTree\n            }),\n        addNode: (parentId, newNode)=>set((state)=>{\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const addRecursive = (node)=>{\n                    if (node.id === parentId) {\n                        node.children.push(newNode);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (addRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                addRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            }),\n        removeNode: (nodeId)=>set((state)=>{\n                if (nodeId === 'root') return state;\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const removeRecursive = (node)=>{\n                    const index = node.children.findIndex((c)=>c.id === nodeId);\n                    if (index !== -1) {\n                        node.children.splice(index, 1);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (removeRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                removeRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            }),\n        updateNodeAttributes: (nodeId, attributes)=>set((state)=>{\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const updateRecursive = (node)=>{\n                    if (node.id === nodeId) {\n                        Object.assign(node, attributes);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (updateRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                updateRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            })\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9nYW1lU3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0M7QUFxRWhDLE1BQU1DLGNBQThCO0lBQ2xDQyxJQUFJO0lBQ0pDLE1BQU07SUFDTkMsVUFBVSxFQUFFO0FBQ2Q7QUFFTyxNQUFNQyxlQUFlTCwrQ0FBTUEsQ0FBWSxDQUFDTSxNQUFTO1FBQ3REQyxXQUFXO1FBQ1hDLGFBQWE7UUFDYkMsT0FBTztRQUNQQyxlQUFlO1FBQ2ZDLGNBQWM7UUFDZEMsY0FBYztRQUNkQyxNQUFNWjtRQUNOYSx5QkFBeUIsRUFBRTtRQUMzQkMsV0FBVztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBRXRDLG1CQUFtQjtRQUNuQkMsY0FBYztRQUNkQyxjQUFjO1FBQ2RDLGNBQWM7UUFDZEMsb0JBQW9CO1FBRXBCQyxjQUFjLENBQUNDLE9BQVNmLElBQUk7Z0JBQUVDLFdBQVdjO2dCQUFNUCx5QkFBeUIsRUFBRTtZQUFDO1FBRTNFUSxnQkFBZ0IsQ0FBQ0MsT0FBU2pCLElBQUksQ0FBQ2tCO2dCQUM3QixNQUFNQyxrQkFBa0JGLFNBQVMsV0FBVyxVQUFVO2dCQUN0RCxJQUFJRztnQkFDSixJQUFJQztnQkFFSixJQUFJSixTQUFTLGFBQWE7b0JBQ3hCRyxVQUFVO3dCQUFFeEIsSUFBSTt3QkFBUUMsTUFBTTt3QkFBU0MsVUFBVSxFQUFFO3dCQUFFd0IsWUFBWUMsTUFBTSxHQUFHQyxJQUFJLENBQUM7b0JBQU07b0JBQ3JGSCxlQUFlO2dCQUNqQixPQUFPLElBQUlKLFNBQVMsV0FBVztvQkFDN0JHLFVBQVU7d0JBQUV4QixJQUFJO3dCQUFRQyxNQUFNO3dCQUFTQyxVQUFVLEVBQUU7d0JBQUV3QixZQUFZOzRCQUFDOzRCQUFHOzRCQUFHOzRCQUFHOzRCQUFHOzRCQUFHOzRCQUFHOzRCQUFHOzRCQUFHO3lCQUFFO29CQUFDO29CQUM3RkQsZUFBZTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtnQkFDNUMsT0FBTztvQkFDTEQsVUFBVTt3QkFBRXhCLElBQUk7d0JBQVFDLE1BQU07d0JBQVNDLFVBQVUsRUFBRTtvQkFBQztvQkFDcER1QixlQUFlO2dCQUNqQjtnQkFFQSxPQUFPO29CQUNMbkIsYUFBYWU7b0JBQ2JWLE1BQU1hO29CQUNOZCxjQUFjWSxNQUFNWixZQUFZLEdBQUc7b0JBQ25DRyxXQUFXWTtvQkFDWFQsY0FBY087b0JBQ2RYLHlCQUF5QixFQUFFO29CQUMzQkosZUFBZTtvQkFDZkMsY0FBYztnQkFDaEI7WUFDRjtRQUVBb0IsVUFBVSxDQUFDdEIsUUFBVUgsSUFBSTtnQkFBRUc7WUFBTTtRQUNqQ3VCLGdCQUFnQixJQUFNMUIsSUFBSSxDQUFDa0IsUUFBVztvQkFBRWQsZUFBZWMsTUFBTWQsYUFBYSxHQUFHO2dCQUFFO1FBQy9FdUIsa0JBQWtCLElBQU0zQixJQUFJLENBQUNrQixRQUFXO29CQUFFYixjQUFjLENBQUNhLE1BQU1iLFlBQVk7Z0JBQUM7UUFFNUV1QixPQUFPLElBQU01QixJQUFJLENBQUNrQixRQUFXO29CQUMzQmYsT0FBTztvQkFDUEMsZUFBZTtvQkFDZkMsY0FBYztvQkFDZEMsY0FBY1ksTUFBTVosWUFBWSxHQUFHO29CQUNuQ0UseUJBQXlCLEVBQUU7Z0JBQzdCO1FBRUFxQixrQkFBa0IsQ0FBQ0MsUUFBVTlCLElBQUk7Z0JBQUVJLGVBQWUwQjtZQUFNO1FBRXhEQyxpQkFBaUIsQ0FBQ0MsUUFBVWhDLElBQUk7Z0JBQUVVLGNBQWNzQjtZQUFNO1FBQ3REQyxpQkFBaUIsQ0FBQ0QsUUFBVWhDLElBQUk7Z0JBQUVXLGNBQWNxQjtZQUFNO1FBQ3RERSxpQkFBaUIsQ0FBQ0MsT0FBU25DLElBQUk7Z0JBQUVZLGNBQWN1QjtZQUFLO1FBQ3BEQyxjQUFjLENBQUNsQixRQUFVbEIsSUFBSTtnQkFBRVMsV0FBV1M7WUFBTTtRQUNoRG1CLHVCQUF1QixDQUFDQyxTQUFXdEMsSUFBSTtnQkFBRWEsb0JBQW9CeUI7WUFBTztRQUVwRUMsNEJBQTRCLENBQUNDLE1BQVF4QyxJQUFJO2dCQUFFUSx5QkFBeUJnQztZQUFJO1FBRXhFQyxZQUFZLENBQUNyQixVQUFZcEIsSUFBSTtnQkFBRU8sTUFBTWE7WUFBUTtRQUU3Q3NCLFNBQVMsQ0FBQ0MsVUFBVUMsVUFBWTVDLElBQUksQ0FBQ2tCO2dCQUNuQyxNQUFNRSxVQUFVeUIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUM3QixNQUFNWCxJQUFJO2dCQUNwRCxNQUFNeUMsZUFBZSxDQUFDQztvQkFDcEIsSUFBSUEsS0FBS3JELEVBQUUsS0FBSytDLFVBQVU7d0JBQ3hCTSxLQUFLbkQsUUFBUSxDQUFDb0QsSUFBSSxDQUFDTjt3QkFDbkIsT0FBTztvQkFDVDtvQkFDQSxLQUFLLE1BQU1PLFNBQVNGLEtBQUtuRCxRQUFRLENBQUU7d0JBQ2pDLElBQUlrRCxhQUFhRyxRQUFRLE9BQU87b0JBQ2xDO29CQUNBLE9BQU87Z0JBQ1Q7Z0JBQ0FILGFBQWE1QjtnQkFDYixPQUFPO29CQUFFYixNQUFNYTtnQkFBUTtZQUN6QjtRQUVBZ0MsWUFBWSxDQUFDQyxTQUFXckQsSUFBSSxDQUFDa0I7Z0JBQzNCLElBQUltQyxXQUFXLFFBQVEsT0FBT25DO2dCQUM5QixNQUFNRSxVQUFVeUIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUM3QixNQUFNWCxJQUFJO2dCQUNwRCxNQUFNK0Msa0JBQWtCLENBQUNMO29CQUN2QixNQUFNTSxRQUFRTixLQUFLbkQsUUFBUSxDQUFDMEQsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFN0QsRUFBRSxLQUFLeUQ7b0JBQ3BELElBQUlFLFVBQVUsQ0FBQyxHQUFHO3dCQUNoQk4sS0FBS25ELFFBQVEsQ0FBQzRELE1BQU0sQ0FBQ0gsT0FBTzt3QkFDNUIsT0FBTztvQkFDVDtvQkFDQSxLQUFLLE1BQU1KLFNBQVNGLEtBQUtuRCxRQUFRLENBQUU7d0JBQ2pDLElBQUl3RCxnQkFBZ0JILFFBQVEsT0FBTztvQkFDckM7b0JBQ0EsT0FBTztnQkFDVDtnQkFDQUcsZ0JBQWdCbEM7Z0JBQ2hCLE9BQU87b0JBQUViLE1BQU1hO2dCQUFRO1lBQ3pCO1FBRUF1QyxzQkFBc0IsQ0FBQ04sUUFBUU8sYUFBZTVELElBQUksQ0FBQ2tCO2dCQUNqRCxNQUFNRSxVQUFVeUIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUM3QixNQUFNWCxJQUFJO2dCQUNwRCxNQUFNc0Qsa0JBQWtCLENBQUNaO29CQUN2QixJQUFJQSxLQUFLckQsRUFBRSxLQUFLeUQsUUFBUTt3QkFDdEJTLE9BQU9DLE1BQU0sQ0FBQ2QsTUFBTVc7d0JBQ3BCLE9BQU87b0JBQ1Q7b0JBQ0EsS0FBSyxNQUFNVCxTQUFTRixLQUFLbkQsUUFBUSxDQUFFO3dCQUNqQyxJQUFJK0QsZ0JBQWdCVixRQUFRLE9BQU87b0JBQ3JDO29CQUNBLE9BQU87Z0JBQ1Q7Z0JBQ0FVLGdCQUFnQnpDO2dCQUNoQixPQUFPO29CQUFFYixNQUFNYTtnQkFBUTtZQUN6QjtJQUNGLElBQUciLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYnJhbmRcXE9uZURyaXZlXFxEb2N1bWVudG9zXFxHaXRIdWJcXGFsZ29yaXRobV9JQVxcc3JjXFxzdG9yZVxcZ2FtZVN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnXHJcblxyXG5leHBvcnQgdHlwZSBBbGdvcml0aG1UeXBlID1cclxuICB8ICdiZnMnIHwgJ2RmcycgfCAnaWRzJyB8ICd1Y3MnIHwgJ2dyZWVkeScgfCAnYXN0YXInIHwgJ2lkYXN0YXInXHJcbiAgfCAnbWluaW1heCcgfCAnYWxwaGEtYmV0YScgfCAnbWN0cydcclxuICB8IG51bGw7XHJcblxyXG5leHBvcnQgdHlwZSBQcm9ibGVtVHlwZSA9ICdjdXN0b20nIHwgJ3RpY3RhY3RvZScgfCAnOHB1enpsZSc7XHJcblxyXG5leHBvcnQgdHlwZSBOb2RlU2hhcGUgPSAnY2lyY2xlJyB8ICd0cmlhbmdsZScgfCAnc3F1YXJlJztcclxuXHJcbmV4cG9ydCB0eXBlIE5vZGVWaWV3TW9kZSA9ICdzaGFwZScgfCAnZ2FtZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVRyZWVOb2RlIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICB2YWx1ZT86IG51bWJlcjsgLy8gSGV1csOtc3RpY2Egb3UgVXRpbGlkYWRlXHJcbiAgY2hpbGRyZW46IEN1c3RvbVRyZWVOb2RlW107XHJcbiAgaXNHb2FsPzogYm9vbGVhbjtcclxuICBjb3N0VG9QYXJlbnQ/OiBudW1iZXI7IC8vIEN1c3RvIGRhIGFyZXN0YVxyXG4gIGJvYXJkU3RhdGU/OiBhbnk7IC8vIFBhcmEgVGljVGFjVG9lIG91IDgtUHV6emxlXHJcbn1cclxuXHJcbmludGVyZmFjZSBHYW1lU3RhdGUge1xyXG4gIGFsZ29yaXRobTogQWxnb3JpdGhtVHlwZVxyXG4gIHByb2JsZW1UeXBlOiBQcm9ibGVtVHlwZVxyXG4gIGRlcHRoOiBudW1iZXJcclxuICBub2Rlc0V4cGxvcmVkOiBudW1iZXJcclxuICBpc1NpbXVsYXRpbmc6IGJvb2xlYW5cclxuICByZXNldFRyaWdnZXI6IG51bWJlclxyXG5cclxuICAvLyBDb25maWd1cmHDp8O1ZXMgVmlzdWFpcyBlIGRlIEpvZ29cclxuICBtYXhOb2RlU2hhcGU6IE5vZGVTaGFwZVxyXG4gIG1pbk5vZGVTaGFwZTogTm9kZVNoYXBlXHJcbiAgbm9kZVZpZXdNb2RlOiBOb2RlVmlld01vZGVcclxuICBnb2FsU3RhdGU6IGFueSB8IG51bGxcclxuICB0aWNUYWNUb2VNYXhQbGF5ZXI6ICdYJyB8ICdPJ1xyXG5cclxuICAvLyBJRHMgZGUgbsOzcyBxdWUgdmlvbGFtIGEgYWRtaXNzaWJpbGlkYWRlXHJcbiAgYWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IHN0cmluZ1tdXHJcblxyXG4gIC8vIEVzdGFkbyBkYSDDgXJ2b3JlIEN1c3RvbWl6YWRhXHJcbiAgdHJlZTogQ3VzdG9tVHJlZU5vZGVcclxuXHJcbiAgc2V0QWxnb3JpdGhtOiAoYWxnbzogQWxnb3JpdGhtVHlwZSkgPT4gdm9pZFxyXG4gIHNldFByb2JsZW1UeXBlOiAodHlwZTogUHJvYmxlbVR5cGUpID0+IHZvaWRcclxuICBzZXREZXB0aDogKGRlcHRoOiBudW1iZXIpID0+IHZvaWRcclxuICBpbmNyZW1lbnROb2RlczogKCkgPT4gdm9pZFxyXG4gIHRvZ2dsZVNpbXVsYXRpb246ICgpID0+IHZvaWRcclxuICByZXNldDogKCkgPT4gdm9pZFxyXG4gIFxyXG4gIC8vIEHDp8O1ZXMgZGUgQ29uZmlndXJhw6fDo29cclxuICBzZXRNYXhOb2RlU2hhcGU6IChzaGFwZTogTm9kZVNoYXBlKSA9PiB2b2lkXHJcbiAgc2V0TWluTm9kZVNoYXBlOiAoc2hhcGU6IE5vZGVTaGFwZSkgPT4gdm9pZFxyXG4gIHNldE5vZGVWaWV3TW9kZTogKG1vZGU6IE5vZGVWaWV3TW9kZSkgPT4gdm9pZFxyXG4gIHNldEdvYWxTdGF0ZTogKHN0YXRlOiBhbnkpID0+IHZvaWRcclxuICBzZXRUaWNUYWNUb2VNYXhQbGF5ZXI6IChwbGF5ZXI6ICdYJyB8ICdPJykgPT4gdm9pZFxyXG5cclxuICAvLyBBw6fDtWVzIGRlIEFkbWlzc2liaWxpZGFkZVxyXG4gIHNldEFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiAoaWRzOiBzdHJpbmdbXSkgPT4gdm9pZFxyXG5cclxuICAvLyBBw6fDtWVzIGRlIEVkacOnw6NvIGRhIMOBcnZvcmVcclxuICB1cGRhdGVUcmVlOiAobmV3VHJlZTogQ3VzdG9tVHJlZU5vZGUpID0+IHZvaWRcclxuICBhZGROb2RlOiAocGFyZW50SWQ6IHN0cmluZywgbm9kZTogQ3VzdG9tVHJlZU5vZGUpID0+IHZvaWRcclxuICByZW1vdmVOb2RlOiAobm9kZUlkOiBzdHJpbmcpID0+IHZvaWRcclxuICB1cGRhdGVOb2RlQXR0cmlidXRlczogKG5vZGVJZDogc3RyaW5nLCBhdHRyaWJ1dGVzOiBQYXJ0aWFsPEN1c3RvbVRyZWVOb2RlPikgPT4gdm9pZFxyXG4gIHNldE5vZGVzRXhwbG9yZWQ6IChjb3VudDogbnVtYmVyKSA9PiB2b2lkXHJcbn1cclxuXHJcbmNvbnN0IGluaXRpYWxUcmVlOiBDdXN0b21UcmVlTm9kZSA9IHtcclxuICBpZDogJ3Jvb3QnLFxyXG4gIG5hbWU6ICdTdGFydCcsXHJcbiAgY2hpbGRyZW46IFtdLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUdhbWVTdG9yZSA9IGNyZWF0ZTxHYW1lU3RhdGU+KChzZXQpID0+ICh7XHJcbiAgYWxnb3JpdGhtOiBudWxsLFxyXG4gIHByb2JsZW1UeXBlOiAnY3VzdG9tJyxcclxuICBkZXB0aDogMCxcclxuICBub2Rlc0V4cGxvcmVkOiAwLFxyXG4gIGlzU2ltdWxhdGluZzogZmFsc2UsXHJcbiAgcmVzZXRUcmlnZ2VyOiAwLFxyXG4gIHRyZWU6IGluaXRpYWxUcmVlLFxyXG4gIGFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiBbXSxcclxuICBnb2FsU3RhdGU6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAwXSxcclxuXHJcbiAgLy8gRGVmYXVsdCBzZXR0aW5nc1xyXG4gIG1heE5vZGVTaGFwZTogJ3RyaWFuZ2xlJyxcclxuICBtaW5Ob2RlU2hhcGU6ICdjaXJjbGUnLFxyXG4gIG5vZGVWaWV3TW9kZTogJ3NoYXBlJyxcclxuICB0aWNUYWNUb2VNYXhQbGF5ZXI6ICdYJyxcclxuXHJcbiAgc2V0QWxnb3JpdGhtOiAoYWxnbykgPT4gc2V0KHsgYWxnb3JpdGhtOiBhbGdvLCBhZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogW10gfSksXHJcbiAgXHJcbiAgc2V0UHJvYmxlbVR5cGU6ICh0eXBlKSA9PiBzZXQoKHN0YXRlKSA9PiB7XHJcbiAgICBjb25zdCBuZXdOb2RlVmlld01vZGUgPSB0eXBlID09PSAnY3VzdG9tJyA/ICdzaGFwZScgOiAnZ2FtZSc7XHJcbiAgICBsZXQgbmV3VHJlZTogQ3VzdG9tVHJlZU5vZGU7XHJcbiAgICBsZXQgbmV3R29hbFN0YXRlOiBhbnk7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICd0aWN0YWN0b2UnKSB7XHJcbiAgICAgIG5ld1RyZWUgPSB7IGlkOiAncm9vdCcsIG5hbWU6ICdTdGFydCcsIGNoaWxkcmVuOiBbXSwgYm9hcmRTdGF0ZTogQXJyYXkoOSkuZmlsbChudWxsKSB9O1xyXG4gICAgICBuZXdHb2FsU3RhdGUgPSBudWxsO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnOHB1enpsZScpIHtcclxuICAgICAgbmV3VHJlZSA9IHsgaWQ6ICdyb290JywgbmFtZTogJ1N0YXJ0JywgY2hpbGRyZW46IFtdLCBib2FyZFN0YXRlOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgMF0gfTtcclxuICAgICAgbmV3R29hbFN0YXRlID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDBdO1xyXG4gICAgfSBlbHNlIHsgLy8gY3VzdG9tXHJcbiAgICAgIG5ld1RyZWUgPSB7IGlkOiAncm9vdCcsIG5hbWU6ICdTdGFydCcsIGNoaWxkcmVuOiBbXSB9O1xyXG4gICAgICBuZXdHb2FsU3RhdGUgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IFxyXG4gICAgICBwcm9ibGVtVHlwZTogdHlwZSwgXHJcbiAgICAgIHRyZWU6IG5ld1RyZWUsXHJcbiAgICAgIHJlc2V0VHJpZ2dlcjogc3RhdGUucmVzZXRUcmlnZ2VyICsgMSwgXHJcbiAgICAgIGdvYWxTdGF0ZTogbmV3R29hbFN0YXRlLFxyXG4gICAgICBub2RlVmlld01vZGU6IG5ld05vZGVWaWV3TW9kZSxcclxuICAgICAgYWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IFtdLFxyXG4gICAgICBub2Rlc0V4cGxvcmVkOiAwLFxyXG4gICAgICBpc1NpbXVsYXRpbmc6IGZhbHNlLFxyXG4gICAgfTtcclxuICB9KSxcclxuXHJcbiAgc2V0RGVwdGg6IChkZXB0aCkgPT4gc2V0KHsgZGVwdGggfSksXHJcbiAgaW5jcmVtZW50Tm9kZXM6ICgpID0+IHNldCgoc3RhdGUpID0+ICh7IG5vZGVzRXhwbG9yZWQ6IHN0YXRlLm5vZGVzRXhwbG9yZWQgKyAxIH0pKSxcclxuICB0b2dnbGVTaW11bGF0aW9uOiAoKSA9PiBzZXQoKHN0YXRlKSA9PiAoeyBpc1NpbXVsYXRpbmc6ICFzdGF0ZS5pc1NpbXVsYXRpbmcgfSkpLFxyXG4gIFxyXG4gIHJlc2V0OiAoKSA9PiBzZXQoKHN0YXRlKSA9PiAoeyBcclxuICAgIGRlcHRoOiAwLCBcclxuICAgIG5vZGVzRXhwbG9yZWQ6IDAsIFxyXG4gICAgaXNTaW11bGF0aW5nOiBmYWxzZSxcclxuICAgIHJlc2V0VHJpZ2dlcjogc3RhdGUucmVzZXRUcmlnZ2VyICsgMSxcclxuICAgIGFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiBbXVxyXG4gIH0pKSxcclxuICBcclxuICBzZXROb2Rlc0V4cGxvcmVkOiAoY291bnQpID0+IHNldCh7IG5vZGVzRXhwbG9yZWQ6IGNvdW50IH0pLFxyXG5cclxuICBzZXRNYXhOb2RlU2hhcGU6IChzaGFwZSkgPT4gc2V0KHsgbWF4Tm9kZVNoYXBlOiBzaGFwZSB9KSxcclxuICBzZXRNaW5Ob2RlU2hhcGU6IChzaGFwZSkgPT4gc2V0KHsgbWluTm9kZVNoYXBlOiBzaGFwZSB9KSxcclxuICBzZXROb2RlVmlld01vZGU6IChtb2RlKSA9PiBzZXQoeyBub2RlVmlld01vZGU6IG1vZGUgfSksXHJcbiAgc2V0R29hbFN0YXRlOiAoc3RhdGUpID0+IHNldCh7IGdvYWxTdGF0ZTogc3RhdGUgfSksXHJcbiAgc2V0VGljVGFjVG9lTWF4UGxheWVyOiAocGxheWVyKSA9PiBzZXQoeyB0aWNUYWNUb2VNYXhQbGF5ZXI6IHBsYXllciB9KSxcclxuXHJcbiAgc2V0QWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IChpZHMpID0+IHNldCh7IGFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiBpZHMgfSksXHJcblxyXG4gIHVwZGF0ZVRyZWU6IChuZXdUcmVlKSA9PiBzZXQoeyB0cmVlOiBuZXdUcmVlIH0pLFxyXG5cclxuICBhZGROb2RlOiAocGFyZW50SWQsIG5ld05vZGUpID0+IHNldCgoc3RhdGUpID0+IHtcclxuICAgIGNvbnN0IG5ld1RyZWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpKTtcclxuICAgIGNvbnN0IGFkZFJlY3Vyc2l2ZSA9IChub2RlOiBDdXN0b21UcmVlTm9kZSkgPT4ge1xyXG4gICAgICBpZiAobm9kZS5pZCA9PT0gcGFyZW50SWQpIHtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKGFkZFJlY3Vyc2l2ZShjaGlsZCkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBhZGRSZWN1cnNpdmUobmV3VHJlZSk7XHJcbiAgICByZXR1cm4geyB0cmVlOiBuZXdUcmVlIH07XHJcbiAgfSksXHJcblxyXG4gIHJlbW92ZU5vZGU6IChub2RlSWQpID0+IHNldCgoc3RhdGUpID0+IHtcclxuICAgIGlmIChub2RlSWQgPT09ICdyb290JykgcmV0dXJuIHN0YXRlO1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSkpO1xyXG4gICAgY29uc3QgcmVtb3ZlUmVjdXJzaXZlID0gKG5vZGU6IEN1c3RvbVRyZWVOb2RlKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gbm9kZS5jaGlsZHJlbi5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBub2RlSWQpO1xyXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChyZW1vdmVSZWN1cnNpdmUoY2hpbGQpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmVtb3ZlUmVjdXJzaXZlKG5ld1RyZWUpO1xyXG4gICAgcmV0dXJuIHsgdHJlZTogbmV3VHJlZSB9O1xyXG4gIH0pLFxyXG5cclxuICB1cGRhdGVOb2RlQXR0cmlidXRlczogKG5vZGVJZCwgYXR0cmlidXRlcykgPT4gc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSkpO1xyXG4gICAgY29uc3QgdXBkYXRlUmVjdXJzaXZlID0gKG5vZGU6IEN1c3RvbVRyZWVOb2RlKSA9PiB7XHJcbiAgICAgIGlmIChub2RlLmlkID09PSBub2RlSWQpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIGlmICh1cGRhdGVSZWN1cnNpdmUoY2hpbGQpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgdXBkYXRlUmVjdXJzaXZlKG5ld1RyZWUpO1xyXG4gICAgcmV0dXJuIHsgdHJlZTogbmV3VHJlZSB9O1xyXG4gIH0pXHJcbn0pKVxyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwiaW5pdGlhbFRyZWUiLCJpZCIsIm5hbWUiLCJjaGlsZHJlbiIsInVzZUdhbWVTdG9yZSIsInNldCIsImFsZ29yaXRobSIsInByb2JsZW1UeXBlIiwiZGVwdGgiLCJub2Rlc0V4cGxvcmVkIiwiaXNTaW11bGF0aW5nIiwicmVzZXRUcmlnZ2VyIiwidHJlZSIsImFkbWlzc2liaWxpdHlWaW9sYXRpb25zIiwiZ29hbFN0YXRlIiwibWF4Tm9kZVNoYXBlIiwibWluTm9kZVNoYXBlIiwibm9kZVZpZXdNb2RlIiwidGljVGFjVG9lTWF4UGxheWVyIiwic2V0QWxnb3JpdGhtIiwiYWxnbyIsInNldFByb2JsZW1UeXBlIiwidHlwZSIsInN0YXRlIiwibmV3Tm9kZVZpZXdNb2RlIiwibmV3VHJlZSIsIm5ld0dvYWxTdGF0ZSIsImJvYXJkU3RhdGUiLCJBcnJheSIsImZpbGwiLCJzZXREZXB0aCIsImluY3JlbWVudE5vZGVzIiwidG9nZ2xlU2ltdWxhdGlvbiIsInJlc2V0Iiwic2V0Tm9kZXNFeHBsb3JlZCIsImNvdW50Iiwic2V0TWF4Tm9kZVNoYXBlIiwic2hhcGUiLCJzZXRNaW5Ob2RlU2hhcGUiLCJzZXROb2RlVmlld01vZGUiLCJtb2RlIiwic2V0R29hbFN0YXRlIiwic2V0VGljVGFjVG9lTWF4UGxheWVyIiwicGxheWVyIiwic2V0QWRtaXNzaWJpbGl0eVZpb2xhdGlvbnMiLCJpZHMiLCJ1cGRhdGVUcmVlIiwiYWRkTm9kZSIsInBhcmVudElkIiwibmV3Tm9kZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImFkZFJlY3Vyc2l2ZSIsIm5vZGUiLCJwdXNoIiwiY2hpbGQiLCJyZW1vdmVOb2RlIiwibm9kZUlkIiwicmVtb3ZlUmVjdXJzaXZlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJjIiwic3BsaWNlIiwidXBkYXRlTm9kZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwidXBkYXRlUmVjdXJzaXZlIiwiT2JqZWN0IiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/gameStore.ts\n"));

/***/ })

});