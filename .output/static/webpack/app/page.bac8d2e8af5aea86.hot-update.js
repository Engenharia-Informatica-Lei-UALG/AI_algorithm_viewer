"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useSimulation.ts":
/*!************************************!*\
  !*** ./src/hooks/useSimulation.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSimulation: () => (/* binding */ useSimulation)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _store_gameStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/store/gameStore */ \"(app-pages-browser)/./src/store/gameStore.ts\");\n/* harmony import */ var _lib_ai_problems_CustomTreeProblem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/ai/problems/CustomTreeProblem */ \"(app-pages-browser)/./src/lib/ai/problems/CustomTreeProblem.ts\");\n/* harmony import */ var _lib_ai_problems_TicTacToe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/ai/problems/TicTacToe */ \"(app-pages-browser)/./src/lib/ai/problems/TicTacToe.ts\");\n/* harmony import */ var _lib_ai_problems_EightPuzzle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/ai/problems/EightPuzzle */ \"(app-pages-browser)/./src/lib/ai/problems/EightPuzzle.ts\");\n/* harmony import */ var _lib_ai_algorithms_FrontierSearch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/ai/algorithms/FrontierSearch */ \"(app-pages-browser)/./src/lib/ai/algorithms/FrontierSearch.ts\");\n/* harmony import */ var _lib_ai_algorithms_Minimax__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/ai/algorithms/Minimax */ \"(app-pages-browser)/./src/lib/ai/algorithms/Minimax.ts\");\n/* harmony import */ var _lib_ai_algorithms_MCTS__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/lib/ai/algorithms/MCTS */ \"(app-pages-browser)/./src/lib/ai/algorithms/MCTS.ts\");\n/* harmony import */ var _lib_ai_core_SearchAlgorithm__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/lib/ai/core/SearchAlgorithm */ \"(app-pages-browser)/./src/lib/ai/core/SearchAlgorithm.ts\");\n\n\n\n\n\n\n\n\n\nfunction useSimulation() {\n    const { algorithm, tree, isSimulating, toggleSimulation, setNodesExplored, resetTrigger, problemType, goalState, updateTree } = (0,_store_gameStore__WEBPACK_IMPORTED_MODULE_1__.useGameStore)();\n    const searchAlgoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const problemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [history, setHistory] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [currentStep, setCurrentStep] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const timerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Inicializa o problema e o algoritmo\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSimulation.useEffect\": ()=>{\n            if (!algorithm) return;\n            setHistory([]);\n            setCurrentStep(0);\n            setNodesExplored(0);\n            let problem;\n            // 1. Cria a instância do problema\n            switch(problemType){\n                case 'tictactoe':\n                    problem = new _lib_ai_problems_TicTacToe__WEBPACK_IMPORTED_MODULE_3__.TicTacToe(tree.boardState); // Passa o estado inicial configurado\n                    break;\n                case '8puzzle':\n                    problem = new _lib_ai_problems_EightPuzzle__WEBPACK_IMPORTED_MODULE_4__.EightPuzzle(tree.boardState, goalState); // Passa estado inicial e objetivo\n                    break;\n                case 'custom':\n                default:\n                    problem = new _lib_ai_problems_CustomTreeProblem__WEBPACK_IMPORTED_MODULE_2__.CustomTreeProblem(tree);\n                    break;\n            }\n            problemRef.current = problem;\n            // 2. Cria a instância do algoritmo com o problema\n            let algoInstance = null;\n            switch(algorithm){\n                case 'bfs':\n                    algoInstance = _lib_ai_algorithms_FrontierSearch__WEBPACK_IMPORTED_MODULE_5__.FrontierSearch.createBFS(problem);\n                    break;\n                case 'dfs':\n                    algoInstance = _lib_ai_algorithms_FrontierSearch__WEBPACK_IMPORTED_MODULE_5__.FrontierSearch.createDFS(problem);\n                    break;\n                case 'astar':\n                    algoInstance = _lib_ai_algorithms_FrontierSearch__WEBPACK_IMPORTED_MODULE_5__.FrontierSearch.createAStar(problem);\n                    break;\n                case 'greedy':\n                    algoInstance = _lib_ai_algorithms_FrontierSearch__WEBPACK_IMPORTED_MODULE_5__.FrontierSearch.createGreedy(problem);\n                    break;\n                case 'ucs':\n                    algoInstance = _lib_ai_algorithms_FrontierSearch__WEBPACK_IMPORTED_MODULE_5__.FrontierSearch.createUCS(problem);\n                    break;\n                case 'minimax':\n                    algoInstance = new _lib_ai_algorithms_Minimax__WEBPACK_IMPORTED_MODULE_6__.Minimax(problem, 10, false);\n                    break;\n                case 'alpha-beta':\n                    algoInstance = new _lib_ai_algorithms_Minimax__WEBPACK_IMPORTED_MODULE_6__.Minimax(problem, 10, true);\n                    break;\n                case 'mcts':\n                    algoInstance = new _lib_ai_algorithms_MCTS__WEBPACK_IMPORTED_MODULE_7__.MCTS(problem, 100);\n                    break;\n                default:\n                    console.warn(\"Algoritmo não implementado:\", algorithm);\n            }\n            searchAlgoRef.current = algoInstance;\n        }\n    }[\"useSimulation.useEffect\"], [\n        algorithm,\n        tree,\n        resetTrigger,\n        problemType,\n        goalState,\n        setNodesExplored\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSimulation.useEffect\": ()=>{\n            setNodesExplored(currentStep);\n        }\n    }[\"useSimulation.useEffect\"], [\n        currentStep,\n        setNodesExplored\n    ]);\n    const executeStep = ()=>{\n        if (currentStep < history.length) {\n            setCurrentStep((c)=>c + 1);\n            return;\n        }\n        const algo = searchAlgoRef.current;\n        if (!algo) return;\n        if (algo.getStatus() === _lib_ai_core_SearchAlgorithm__WEBPACK_IMPORTED_MODULE_8__.SearchStatus.COMPLETED || algo.getStatus() === _lib_ai_core_SearchAlgorithm__WEBPACK_IMPORTED_MODULE_8__.SearchStatus.FAILED) {\n            if (isSimulating) toggleSimulation();\n            return;\n        }\n        const node = algo.step();\n        if (node) {\n            // Para problemas dinâmicos, atualizamos a árvore visual\n            if (problemType !== 'custom') {\n                updateTree(algo.getTree());\n            }\n            const nodeId = node.state.key || node.state.nodeId;\n            if (nodeId) {\n                setHistory((prev)=>[\n                        ...prev,\n                        nodeId\n                    ]);\n                setCurrentStep((c)=>c + 1);\n            }\n        }\n    };\n    const stepBack = ()=>{\n        setCurrentStep((c)=>Math.max(0, c - 1));\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSimulation.useEffect\": ()=>{\n            if (isSimulating && searchAlgoRef.current) {\n                timerRef.current = setInterval(executeStep, 500);\n            } else {\n                if (timerRef.current) clearInterval(timerRef.current);\n            }\n            return ({\n                \"useSimulation.useEffect\": ()=>{\n                    if (timerRef.current) clearInterval(timerRef.current);\n                }\n            })[\"useSimulation.useEffect\"];\n        }\n    }[\"useSimulation.useEffect\"], [\n        isSimulating,\n        history,\n        currentStep,\n        toggleSimulation\n    ]);\n    const visitedNodes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useSimulation.useMemo[visitedNodes]\": ()=>new Set(history.slice(0, currentStep))\n    }[\"useSimulation.useMemo[visitedNodes]\"], [\n        history,\n        currentStep\n    ]);\n    const currentNodeId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useSimulation.useMemo[currentNodeId]\": ()=>history[currentStep - 1] || null\n    }[\"useSimulation.useMemo[currentNodeId]\"], [\n        history,\n        currentStep\n    ]);\n    return {\n        visitedNodes,\n        currentNodeId,\n        stepForward: executeStep,\n        stepBack,\n        fastForward: ()=>{\n            if (!isSimulating) toggleSimulation();\n            if (timerRef.current) clearInterval(timerRef.current);\n            timerRef.current = setInterval(executeStep, 50);\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTaW11bGF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ2dCO0FBQ0w7QUFDaEI7QUFDSTtBQUNRO0FBQ2Q7QUFDTjtBQUM4QjtBQUd2RSxTQUFTWTtJQUNkLE1BQU0sRUFDSkMsU0FBUyxFQUNUQyxJQUFJLEVBQ0pDLFlBQVksRUFDWkMsZ0JBQWdCLEVBQ2hCQyxnQkFBZ0IsRUFDaEJDLFlBQVksRUFDWkMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLFVBQVUsRUFDWCxHQUFHakIsOERBQVlBO0lBRWhCLE1BQU1rQixnQkFBZ0JyQiw2Q0FBTUEsQ0FBbUM7SUFDL0QsTUFBTXNCLGFBQWF0Qiw2Q0FBTUEsQ0FBMkI7SUFFcEQsTUFBTSxDQUFDdUIsU0FBU0MsV0FBVyxHQUFHdkIsK0NBQVFBLENBQVcsRUFBRTtJQUNuRCxNQUFNLENBQUN3QixhQUFhQyxlQUFlLEdBQUd6QiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNMEIsV0FBVzNCLDZDQUFNQSxDQUF3QjtJQUUvQyxzQ0FBc0M7SUFDdENELGdEQUFTQTttQ0FBQztZQUNSLElBQUksQ0FBQ2EsV0FBVztZQUVoQlksV0FBVyxFQUFFO1lBQ2JFLGVBQWU7WUFDZlYsaUJBQWlCO1lBRWpCLElBQUlZO1lBRUosa0NBQWtDO1lBQ2xDLE9BQVFWO2dCQUNOLEtBQUs7b0JBQ0hVLFVBQVUsSUFBSXZCLGlFQUFTQSxDQUFDUSxLQUFLZ0IsVUFBVSxHQUFHLHFDQUFxQztvQkFDL0U7Z0JBQ0YsS0FBSztvQkFDSEQsVUFBVSxJQUFJdEIscUVBQVdBLENBQUNPLEtBQUtnQixVQUFVLEVBQUVWLFlBQVksa0NBQWtDO29CQUN6RjtnQkFDRixLQUFLO2dCQUNMO29CQUNFUyxVQUFVLElBQUl4QixpRkFBaUJBLENBQUNTO29CQUNoQztZQUNKO1lBQ0FTLFdBQVdRLE9BQU8sR0FBR0Y7WUFFckIsa0RBQWtEO1lBQ2xELElBQUlHLGVBQWlEO1lBQ3JE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VSxhQUFhO1lBQ1gsSUFBSSxDQUFDakQsY0FBY0M7WUFDbkIsSUFBSVksU0FBU0csT0FBTyxFQUFFMkIsY0FBYzlCLFNBQVNHLE9BQU87WUFDcERILFNBQVNHLE9BQU8sR0FBRzBCLFlBQVlqQixhQUFhO1FBQzlDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxicmFuZFxcT25lRHJpdmVcXERvY3VtZW50b3NcXEdpdEh1YlxcYWxnb3JpdGhtX0lBXFxzcmNcXGhvb2tzXFx1c2VTaW11bGF0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlR2FtZVN0b3JlLCBBbGdvcml0aG1UeXBlLCBQcm9ibGVtVHlwZSB9IGZyb20gJ0Avc3RvcmUvZ2FtZVN0b3JlJztcclxuaW1wb3J0IHsgQ3VzdG9tVHJlZVByb2JsZW0gfSBmcm9tICdAL2xpYi9haS9wcm9ibGVtcy9DdXN0b21UcmVlUHJvYmxlbSc7XHJcbmltcG9ydCB7IFRpY1RhY1RvZSB9IGZyb20gJ0AvbGliL2FpL3Byb2JsZW1zL1RpY1RhY1RvZSc7XHJcbmltcG9ydCB7IEVpZ2h0UHV6emxlIH0gZnJvbSAnQC9saWIvYWkvcHJvYmxlbXMvRWlnaHRQdXp6bGUnO1xyXG5pbXBvcnQgeyBGcm9udGllclNlYXJjaCB9IGZyb20gJ0AvbGliL2FpL2FsZ29yaXRobXMvRnJvbnRpZXJTZWFyY2gnO1xyXG5pbXBvcnQgeyBNaW5pbWF4IH0gZnJvbSAnQC9saWIvYWkvYWxnb3JpdGhtcy9NaW5pbWF4JztcclxuaW1wb3J0IHsgTUNUUyB9IGZyb20gJ0AvbGliL2FpL2FsZ29yaXRobXMvTUNUUyc7XHJcbmltcG9ydCB7IFNlYXJjaEFsZ29yaXRobSwgU2VhcmNoU3RhdHVzIH0gZnJvbSAnQC9saWIvYWkvY29yZS9TZWFyY2hBbGdvcml0aG0nO1xyXG5pbXBvcnQgeyBQcm9ibGVtIH0gZnJvbSAnQC9saWIvYWkvY29yZS90eXBlcyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlU2ltdWxhdGlvbigpIHtcclxuICBjb25zdCB7IFxyXG4gICAgYWxnb3JpdGhtLCBcclxuICAgIHRyZWUsIFxyXG4gICAgaXNTaW11bGF0aW5nLCBcclxuICAgIHRvZ2dsZVNpbXVsYXRpb24sIFxyXG4gICAgc2V0Tm9kZXNFeHBsb3JlZCwgXHJcbiAgICByZXNldFRyaWdnZXIsXHJcbiAgICBwcm9ibGVtVHlwZSxcclxuICAgIGdvYWxTdGF0ZSxcclxuICAgIHVwZGF0ZVRyZWVcclxuICB9ID0gdXNlR2FtZVN0b3JlKCk7XHJcblxyXG4gIGNvbnN0IHNlYXJjaEFsZ29SZWYgPSB1c2VSZWY8U2VhcmNoQWxnb3JpdGhtPGFueSwgYW55PiB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IHByb2JsZW1SZWYgPSB1c2VSZWY8UHJvYmxlbTxhbnksIGFueT4gfCBudWxsPihudWxsKTtcclxuXHJcbiAgY29uc3QgW2hpc3RvcnksIHNldEhpc3RvcnldID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcclxuICBjb25zdCBbY3VycmVudFN0ZXAsIHNldEN1cnJlbnRTdGVwXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IHRpbWVyUmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIEluaWNpYWxpemEgbyBwcm9ibGVtYSBlIG8gYWxnb3JpdG1vXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghYWxnb3JpdGhtKSByZXR1cm47XHJcblxyXG4gICAgc2V0SGlzdG9yeShbXSk7XHJcbiAgICBzZXRDdXJyZW50U3RlcCgwKTtcclxuICAgIHNldE5vZGVzRXhwbG9yZWQoMCk7XHJcblxyXG4gICAgbGV0IHByb2JsZW06IFByb2JsZW08YW55LCBhbnk+O1xyXG5cclxuICAgIC8vIDEuIENyaWEgYSBpbnN0w6JuY2lhIGRvIHByb2JsZW1hXHJcbiAgICBzd2l0Y2ggKHByb2JsZW1UeXBlKSB7XHJcbiAgICAgIGNhc2UgJ3RpY3RhY3RvZSc6XHJcbiAgICAgICAgcHJvYmxlbSA9IG5ldyBUaWNUYWNUb2UodHJlZS5ib2FyZFN0YXRlKTsgLy8gUGFzc2EgbyBlc3RhZG8gaW5pY2lhbCBjb25maWd1cmFkb1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICc4cHV6emxlJzpcclxuICAgICAgICBwcm9ibGVtID0gbmV3IEVpZ2h0UHV6emxlKHRyZWUuYm9hcmRTdGF0ZSwgZ29hbFN0YXRlKTsgLy8gUGFzc2EgZXN0YWRvIGluaWNpYWwgZSBvYmpldGl2b1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdjdXN0b20nOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHByb2JsZW0gPSBuZXcgQ3VzdG9tVHJlZVByb2JsZW0odHJlZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBwcm9ibGVtUmVmLmN1cnJlbnQgPSBwcm9ibGVtO1xyXG5cclxuICAgIC8vIDIuIENyaWEgYSBpbnN0w6JuY2lhIGRvIGFsZ29yaXRtbyBjb20gbyBwcm9ibGVtYVxyXG4gICAgbGV0IGFsZ29JbnN0YW5jZTogU2VhcmNoQWxnb3JpdGhtPGFueSwgYW55PiB8IG51bGwgPSBudWxsO1xyXG4gICAgc3dpdGNoIChhbGdvcml0aG0pIHtcclxuICAgICAgY2FzZSAnYmZzJzogYWxnb0luc3RhbmNlID0gRnJvbnRpZXJTZWFyY2guY3JlYXRlQkZTKHByb2JsZW0pOyBicmVhaztcclxuICAgICAgY2FzZSAnZGZzJzogYWxnb0luc3RhbmNlID0gRnJvbnRpZXJTZWFyY2guY3JlYXRlREZTKHByb2JsZW0pOyBicmVhaztcclxuICAgICAgY2FzZSAnYXN0YXInOiBhbGdvSW5zdGFuY2UgPSBGcm9udGllclNlYXJjaC5jcmVhdGVBU3Rhcihwcm9ibGVtKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2dyZWVkeSc6IGFsZ29JbnN0YW5jZSA9IEZyb250aWVyU2VhcmNoLmNyZWF0ZUdyZWVkeShwcm9ibGVtKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3Vjcyc6IGFsZ29JbnN0YW5jZSA9IEZyb250aWVyU2VhcmNoLmNyZWF0ZVVDUyhwcm9ibGVtKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21pbmltYXgnOiBhbGdvSW5zdGFuY2UgPSBuZXcgTWluaW1heChwcm9ibGVtLCAxMCwgZmFsc2UpOyBicmVhaztcclxuICAgICAgY2FzZSAnYWxwaGEtYmV0YSc6IGFsZ29JbnN0YW5jZSA9IG5ldyBNaW5pbWF4KHByb2JsZW0sIDEwLCB0cnVlKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21jdHMnOiBhbGdvSW5zdGFuY2UgPSBuZXcgTUNUUyhwcm9ibGVtLCAxMDApOyBicmVhaztcclxuICAgICAgZGVmYXVsdDogY29uc29sZS53YXJuKFwiQWxnb3JpdG1vIG7Do28gaW1wbGVtZW50YWRvOlwiLCBhbGdvcml0aG0pO1xyXG4gICAgfVxyXG4gICAgc2VhcmNoQWxnb1JlZi5jdXJyZW50ID0gYWxnb0luc3RhbmNlO1xyXG5cclxuICB9LCBbYWxnb3JpdGhtLCB0cmVlLCByZXNldFRyaWdnZXIsIHByb2JsZW1UeXBlLCBnb2FsU3RhdGUsIHNldE5vZGVzRXhwbG9yZWRdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHNldE5vZGVzRXhwbG9yZWQoY3VycmVudFN0ZXApO1xyXG4gIH0sIFtjdXJyZW50U3RlcCwgc2V0Tm9kZXNFeHBsb3JlZF0pO1xyXG5cclxuICBjb25zdCBleGVjdXRlU3RlcCA9ICgpID0+IHtcclxuICAgIGlmIChjdXJyZW50U3RlcCA8IGhpc3RvcnkubGVuZ3RoKSB7XHJcbiAgICAgIHNldEN1cnJlbnRTdGVwKGMgPT4gYyArIDEpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWxnbyA9IHNlYXJjaEFsZ29SZWYuY3VycmVudDtcclxuICAgIGlmICghYWxnbykgcmV0dXJuO1xyXG5cclxuICAgIGlmIChhbGdvLmdldFN0YXR1cygpID09PSBTZWFyY2hTdGF0dXMuQ09NUExFVEVEIHx8IGFsZ28uZ2V0U3RhdHVzKCkgPT09IFNlYXJjaFN0YXR1cy5GQUlMRUQpIHtcclxuICAgICAgaWYgKGlzU2ltdWxhdGluZykgdG9nZ2xlU2ltdWxhdGlvbigpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgbm9kZSA9IGFsZ28uc3RlcCgpO1xyXG4gICAgaWYgKG5vZGUpIHtcclxuICAgICAgLy8gUGFyYSBwcm9ibGVtYXMgZGluw6JtaWNvcywgYXR1YWxpemFtb3MgYSDDoXJ2b3JlIHZpc3VhbFxyXG4gICAgICBpZiAocHJvYmxlbVR5cGUgIT09ICdjdXN0b20nKSB7XHJcbiAgICAgICAgdXBkYXRlVHJlZShhbGdvLmdldFRyZWUoKSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IG5vZGVJZCA9IChub2RlLnN0YXRlIGFzIGFueSkua2V5IHx8IChub2RlLnN0YXRlIGFzIGFueSkubm9kZUlkO1xyXG4gICAgICBpZiAobm9kZUlkKSB7XHJcbiAgICAgICAgc2V0SGlzdG9yeShwcmV2ID0+IFsuLi5wcmV2LCBub2RlSWRdKTtcclxuICAgICAgICBzZXRDdXJyZW50U3RlcChjID0+IGMgKyAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHN0ZXBCYWNrID0gKCkgPT4ge1xyXG4gICAgc2V0Q3VycmVudFN0ZXAoYyA9PiBNYXRoLm1heCgwLCBjIC0gMSkpO1xyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoaXNTaW11bGF0aW5nICYmIHNlYXJjaEFsZ29SZWYuY3VycmVudCkge1xyXG4gICAgICB0aW1lclJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoZXhlY3V0ZVN0ZXAsIDUwMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGltZXJSZWYuY3VycmVudCkgY2xlYXJJbnRlcnZhbCh0aW1lclJlZi5jdXJyZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmICh0aW1lclJlZi5jdXJyZW50KSBjbGVhckludGVydmFsKHRpbWVyUmVmLmN1cnJlbnQpO1xyXG4gICAgfTtcclxuICB9LCBbaXNTaW11bGF0aW5nLCBoaXN0b3J5LCBjdXJyZW50U3RlcCwgdG9nZ2xlU2ltdWxhdGlvbl0pO1xyXG5cclxuICBjb25zdCB2aXNpdGVkTm9kZXMgPSB1c2VNZW1vKCgpID0+IG5ldyBTZXQoaGlzdG9yeS5zbGljZSgwLCBjdXJyZW50U3RlcCkpLCBbaGlzdG9yeSwgY3VycmVudFN0ZXBdKTtcclxuICBjb25zdCBjdXJyZW50Tm9kZUlkID0gdXNlTWVtbygoKSA9PiBoaXN0b3J5W2N1cnJlbnRTdGVwIC0gMV0gfHwgbnVsbCwgW2hpc3RvcnksIGN1cnJlbnRTdGVwXSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB2aXNpdGVkTm9kZXMsXHJcbiAgICBjdXJyZW50Tm9kZUlkLFxyXG4gICAgc3RlcEZvcndhcmQ6IGV4ZWN1dGVTdGVwLFxyXG4gICAgc3RlcEJhY2ssXHJcbiAgICBmYXN0Rm9yd2FyZDogKCkgPT4ge1xyXG4gICAgICBpZiAoIWlzU2ltdWxhdGluZykgdG9nZ2xlU2ltdWxhdGlvbigpO1xyXG4gICAgICBpZiAodGltZXJSZWYuY3VycmVudCkgY2xlYXJJbnRlcnZhbCh0aW1lclJlZi5jdXJyZW50KTtcclxuICAgICAgdGltZXJSZWYuY3VycmVudCA9IHNldEludGVydmFsKGV4ZWN1dGVTdGVwLCA1MCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VNZW1vIiwidXNlR2FtZVN0b3JlIiwiQ3VzdG9tVHJlZVByb2JsZW0iLCJUaWNUYWNUb2UiLCJFaWdodFB1enpsZSIsIkZyb250aWVyU2VhcmNoIiwiTWluaW1heCIsIk1DVFMiLCJTZWFyY2hTdGF0dXMiLCJ1c2VTaW11bGF0aW9uIiwiYWxnb3JpdGhtIiwidHJlZSIsImlzU2ltdWxhdGluZyIsInRvZ2dsZVNpbXVsYXRpb24iLCJzZXROb2Rlc0V4cGxvcmVkIiwicmVzZXRUcmlnZ2VyIiwicHJvYmxlbVR5cGUiLCJnb2FsU3RhdGUiLCJ1cGRhdGVUcmVlIiwic2VhcmNoQWxnb1JlZiIsInByb2JsZW1SZWYiLCJoaXN0b3J5Iiwic2V0SGlzdG9yeSIsImN1cnJlbnRTdGVwIiwic2V0Q3VycmVudFN0ZXAiLCJ0aW1lclJlZiIsInByb2JsZW0iLCJib2FyZFN0YXRlIiwiY3VycmVudCIsImFsZ29JbnN0YW5jZSIsImNyZWF0ZUJGUyIsImNyZWF0ZURGUyIsImNyZWF0ZUFTdGFyIiwiY3JlYXRlR3JlZWR5IiwiY3JlYXRlVUNTIiwiY29uc29sZSIsIndhcm4iLCJleGVjdXRlU3RlcCIsImxlbmd0aCIsImMiLCJhbGdvIiwiZ2V0U3RhdHVzIiwiQ09NUExFVEVEIiwiRkFJTEVEIiwibm9kZSIsInN0ZXAiLCJnZXRUcmVlIiwibm9kZUlkIiwic3RhdGUiLCJrZXkiLCJwcmV2Iiwic3RlcEJhY2siLCJNYXRoIiwibWF4Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidmlzaXRlZE5vZGVzIiwiU2V0Iiwic2xpY2UiLCJjdXJyZW50Tm9kZUlkIiwic3RlcEZvcndhcmQiLCJmYXN0Rm9yd2FyZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSimulation.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/ai/problems/EightPuzzle.ts":
/*!********************************************!*\
  !*** ./src/lib/ai/problems/EightPuzzle.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EightPuzzle: () => (/* binding */ EightPuzzle)\n/* harmony export */ });\nclass EightPuzzle {\n    getActions(state) {\n        const actions = [];\n        const { emptyIndex } = state;\n        const size = 3;\n        const row = Math.floor(emptyIndex / size);\n        const col = emptyIndex % size;\n        // Movimentos possíveis do espaço vazio\n        if (row > 0) actions.push({\n            name: 'Move Up',\n            direction: 'UP',\n            targetIndex: emptyIndex - size\n        });\n        if (row < size - 1) actions.push({\n            name: 'Move Down',\n            direction: 'DOWN',\n            targetIndex: emptyIndex + size\n        });\n        if (col > 0) actions.push({\n            name: 'Move Left',\n            direction: 'LEFT',\n            targetIndex: emptyIndex - 1\n        });\n        if (col < size - 1) actions.push({\n            name: 'Move Right',\n            direction: 'RIGHT',\n            targetIndex: emptyIndex + 1\n        });\n        return actions;\n    }\n    getResult(state, action) {\n        const newBoard = [\n            ...state.board\n        ];\n        // Troca o vazio com a peça alvo\n        [newBoard[state.emptyIndex], newBoard[action.targetIndex]] = [\n            newBoard[action.targetIndex],\n            newBoard[state.emptyIndex]\n        ];\n        return {\n            key: newBoard.join(','),\n            isTerminal: this.isBoardGoal(newBoard),\n            board: newBoard,\n            emptyIndex: action.targetIndex\n        };\n    }\n    isGoal(state) {\n        return state.key === this.goalState.join(',');\n    }\n    isBoardGoal(board) {\n        return board.every((val, idx)=>val === this.goalState[idx]);\n    }\n    getCost(state, action, nextState) {\n        return 1;\n    }\n    // Heurística: Distância de Manhattan\n    getHeuristic(state) {\n        let distance = 0;\n        for(let i = 0; i < 9; i++){\n            const value = state.board[i];\n            if (value !== 0) {\n                // Posição atual\n                const currentRow = Math.floor(i / 3);\n                const currentCol = i % 3;\n                // Posição objetivo (valor - 1, pois 1 está no índice 0)\n                const targetIndex = value - 1; // Assumindo objetivo [1,2,3,4,5,6,7,8,0]\n                // Nota: Se o objetivo for diferente, precisa buscar o índice no array goalState\n                // Mas para o padrão [1..8, 0], value 1 vai para index 0.\n                const targetRow = Math.floor(targetIndex / 3);\n                const targetCol = targetIndex % 3;\n                distance += Math.abs(currentRow - targetRow) + Math.abs(currentCol - targetCol);\n            }\n        }\n        return distance;\n    }\n    constructor(initialBoard){\n        this.goalState = [\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            0\n        ] // Objetivo padrão\n        ;\n        const board = initialBoard || [\n            1,\n            8,\n            2,\n            0,\n            4,\n            3,\n            7,\n            6,\n            5\n        ]; // Um estado inicial solúvel\n        this.initialState = {\n            key: board.join(','),\n            isTerminal: false,\n            board: board,\n            emptyIndex: board.indexOf(0)\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWkvcHJvYmxlbXMvRWlnaHRQdXp6bGUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQVlPLE1BQU1BO0lBY1hDLFdBQVdDLEtBQWtCLEVBQWtCO1FBQzdDLE1BQU1DLFVBQTBCLEVBQUU7UUFDbEMsTUFBTSxFQUFFQyxVQUFVLEVBQUUsR0FBR0Y7UUFDdkIsTUFBTUcsT0FBTztRQUNiLE1BQU1DLE1BQU1DLEtBQUtDLEtBQUssQ0FBQ0osYUFBYUM7UUFDcEMsTUFBTUksTUFBTUwsYUFBYUM7UUFFekIsdUNBQXVDO1FBQ3ZDLElBQUlDLE1BQU0sR0FBR0gsUUFBUU8sSUFBSSxDQUFDO1lBQUVDLE1BQU07WUFBV0MsV0FBVztZQUFNQyxhQUFhVCxhQUFhQztRQUFLO1FBQzdGLElBQUlDLE1BQU1ELE9BQU8sR0FBR0YsUUFBUU8sSUFBSSxDQUFDO1lBQUVDLE1BQU07WUFBYUMsV0FBVztZQUFRQyxhQUFhVCxhQUFhQztRQUFLO1FBQ3hHLElBQUlJLE1BQU0sR0FBR04sUUFBUU8sSUFBSSxDQUFDO1lBQUVDLE1BQU07WUFBYUMsV0FBVztZQUFRQyxhQUFhVCxhQUFhO1FBQUU7UUFDOUYsSUFBSUssTUFBTUosT0FBTyxHQUFHRixRQUFRTyxJQUFJLENBQUM7WUFBRUMsTUFBTTtZQUFjQyxXQUFXO1lBQVNDLGFBQWFULGFBQWE7UUFBRTtRQUV2RyxPQUFPRDtJQUNUO0lBRUFXLFVBQVVaLEtBQWtCLEVBQUVhLE1BQW9CLEVBQWU7UUFDL0QsTUFBTUMsV0FBVztlQUFJZCxNQUFNZSxLQUFLO1NBQUM7UUFDakMsZ0NBQWdDO1FBQ2hDLENBQUNELFFBQVEsQ0FBQ2QsTUFBTUUsVUFBVSxDQUFDLEVBQUVZLFFBQVEsQ0FBQ0QsT0FBT0YsV0FBVyxDQUFDLENBQUMsR0FDMUQ7WUFBQ0csUUFBUSxDQUFDRCxPQUFPRixXQUFXLENBQUM7WUFBRUcsUUFBUSxDQUFDZCxNQUFNRSxVQUFVLENBQUM7U0FBQztRQUUxRCxPQUFPO1lBQ0xjLEtBQUtGLFNBQVNHLElBQUksQ0FBQztZQUNuQkMsWUFBWSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0w7WUFDN0JDLE9BQU9EO1lBQ1BaLFlBQVlXLE9BQU9GLFdBQVc7UUFDaEM7SUFDRjtJQUVBUyxPQUFPcEIsS0FBa0IsRUFBVztRQUNsQyxPQUFPQSxNQUFNZ0IsR0FBRyxLQUFLLElBQUksQ0FBQ0ssU0FBUyxDQUFDSixJQUFJLENBQUM7SUFDM0M7SUFFUUUsWUFBWUosS0FBZSxFQUFXO1FBQzVDLE9BQU9BLE1BQU1PLEtBQUssQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxRQUFRLElBQUksQ0FBQ0YsU0FBUyxDQUFDRyxJQUFJO0lBQzlEO0lBRUFDLFFBQVF6QixLQUFrQixFQUFFYSxNQUFvQixFQUFFYSxTQUFzQixFQUFVO1FBQ2hGLE9BQU87SUFDVDtJQUVBLHFDQUFxQztJQUNyQ0MsYUFBYTNCLEtBQWtCLEVBQVU7UUFDdkMsSUFBSTRCLFdBQVc7UUFDZixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCLE1BQU1DLFFBQVE5QixNQUFNZSxLQUFLLENBQUNjLEVBQUU7WUFDNUIsSUFBSUMsVUFBVSxHQUFHO2dCQUNmLGdCQUFnQjtnQkFDaEIsTUFBTUMsYUFBYTFCLEtBQUtDLEtBQUssQ0FBQ3VCLElBQUk7Z0JBQ2xDLE1BQU1HLGFBQWFILElBQUk7Z0JBRXZCLHdEQUF3RDtnQkFDeEQsTUFBTWxCLGNBQWNtQixRQUFRLEdBQUcseUNBQXlDO2dCQUN4RSxnRkFBZ0Y7Z0JBQ2hGLHlEQUF5RDtnQkFFekQsTUFBTUcsWUFBWTVCLEtBQUtDLEtBQUssQ0FBQ0ssY0FBYztnQkFDM0MsTUFBTXVCLFlBQVl2QixjQUFjO2dCQUVoQ2lCLFlBQVl2QixLQUFLOEIsR0FBRyxDQUFDSixhQUFhRSxhQUFhNUIsS0FBSzhCLEdBQUcsQ0FBQ0gsYUFBYUU7WUFDdkU7UUFDRjtRQUNBLE9BQU9OO0lBQ1Q7SUExRUFRLFlBQVlDLFlBQXVCLENBQUU7YUFGN0JoQixZQUFzQjtZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFLENBQUUsa0JBQWtCOztRQUczRSxNQUFNTixRQUFRc0IsZ0JBQWdCO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUUsRUFBRSw0QkFBNEI7UUFDdkYsSUFBSSxDQUFDQyxZQUFZLEdBQUc7WUFDbEJ0QixLQUFLRCxNQUFNRSxJQUFJLENBQUM7WUFDaEJDLFlBQVk7WUFDWkgsT0FBT0E7WUFDUGIsWUFBWWEsTUFBTXdCLE9BQU8sQ0FBQztRQUM1QjtJQUNGO0FBbUVGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGJyYW5kXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcR2l0SHViXFxhbGdvcml0aG1fSUFcXHNyY1xcbGliXFxhaVxccHJvYmxlbXNcXEVpZ2h0UHV6emxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb2JsZW0sIFN0YXRlLCBBY3Rpb24gfSBmcm9tICcuLi9jb3JlL3R5cGVzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHV6emxlU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XHJcbiAgYm9hcmQ6IG51bWJlcltdOyAvLyBBcnJheSBkZSA5IG7Dum1lcm9zICgwIHJlcHJlc2VudGEgbyBlc3Bhw6dvIHZhemlvKVxyXG4gIGVtcHR5SW5kZXg6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQdXp6bGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xyXG4gIGRpcmVjdGlvbjogJ1VQJyB8ICdET1dOJyB8ICdMRUZUJyB8ICdSSUdIVCc7XHJcbiAgdGFyZ2V0SW5kZXg6IG51bWJlcjsgLy8gUGFyYSBvbmRlIG8gdmF6aW8gdmFpIChvdSBkZSBvbmRlIGEgcGXDp2EgdmVtKVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRWlnaHRQdXp6bGUgaW1wbGVtZW50cyBQcm9ibGVtPFB1enpsZVN0YXRlLCBQdXp6bGVBY3Rpb24+IHtcclxuICBwdWJsaWMgaW5pdGlhbFN0YXRlOiBQdXp6bGVTdGF0ZTtcclxuICBwcml2YXRlIGdvYWxTdGF0ZTogbnVtYmVyW10gPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgMF07IC8vIE9iamV0aXZvIHBhZHLDo29cclxuXHJcbiAgY29uc3RydWN0b3IoaW5pdGlhbEJvYXJkPzogbnVtYmVyW10pIHtcclxuICAgIGNvbnN0IGJvYXJkID0gaW5pdGlhbEJvYXJkIHx8IFsxLCA4LCAyLCAwLCA0LCAzLCA3LCA2LCA1XTsgLy8gVW0gZXN0YWRvIGluaWNpYWwgc29sw7p2ZWxcclxuICAgIHRoaXMuaW5pdGlhbFN0YXRlID0ge1xyXG4gICAgICBrZXk6IGJvYXJkLmpvaW4oJywnKSxcclxuICAgICAgaXNUZXJtaW5hbDogZmFsc2UsXHJcbiAgICAgIGJvYXJkOiBib2FyZCxcclxuICAgICAgZW1wdHlJbmRleDogYm9hcmQuaW5kZXhPZigwKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGdldEFjdGlvbnMoc3RhdGU6IFB1enpsZVN0YXRlKTogUHV6emxlQWN0aW9uW10ge1xyXG4gICAgY29uc3QgYWN0aW9uczogUHV6emxlQWN0aW9uW10gPSBbXTtcclxuICAgIGNvbnN0IHsgZW1wdHlJbmRleCB9ID0gc3RhdGU7XHJcbiAgICBjb25zdCBzaXplID0gMztcclxuICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoZW1wdHlJbmRleCAvIHNpemUpO1xyXG4gICAgY29uc3QgY29sID0gZW1wdHlJbmRleCAlIHNpemU7XHJcblxyXG4gICAgLy8gTW92aW1lbnRvcyBwb3Nzw612ZWlzIGRvIGVzcGHDp28gdmF6aW9cclxuICAgIGlmIChyb3cgPiAwKSBhY3Rpb25zLnB1c2goeyBuYW1lOiAnTW92ZSBVcCcsIGRpcmVjdGlvbjogJ1VQJywgdGFyZ2V0SW5kZXg6IGVtcHR5SW5kZXggLSBzaXplIH0pO1xyXG4gICAgaWYgKHJvdyA8IHNpemUgLSAxKSBhY3Rpb25zLnB1c2goeyBuYW1lOiAnTW92ZSBEb3duJywgZGlyZWN0aW9uOiAnRE9XTicsIHRhcmdldEluZGV4OiBlbXB0eUluZGV4ICsgc2l6ZSB9KTtcclxuICAgIGlmIChjb2wgPiAwKSBhY3Rpb25zLnB1c2goeyBuYW1lOiAnTW92ZSBMZWZ0JywgZGlyZWN0aW9uOiAnTEVGVCcsIHRhcmdldEluZGV4OiBlbXB0eUluZGV4IC0gMSB9KTtcclxuICAgIGlmIChjb2wgPCBzaXplIC0gMSkgYWN0aW9ucy5wdXNoKHsgbmFtZTogJ01vdmUgUmlnaHQnLCBkaXJlY3Rpb246ICdSSUdIVCcsIHRhcmdldEluZGV4OiBlbXB0eUluZGV4ICsgMSB9KTtcclxuXHJcbiAgICByZXR1cm4gYWN0aW9ucztcclxuICB9XHJcblxyXG4gIGdldFJlc3VsdChzdGF0ZTogUHV6emxlU3RhdGUsIGFjdGlvbjogUHV6emxlQWN0aW9uKTogUHV6emxlU3RhdGUge1xyXG4gICAgY29uc3QgbmV3Qm9hcmQgPSBbLi4uc3RhdGUuYm9hcmRdO1xyXG4gICAgLy8gVHJvY2EgbyB2YXppbyBjb20gYSBwZcOnYSBhbHZvXHJcbiAgICBbbmV3Qm9hcmRbc3RhdGUuZW1wdHlJbmRleF0sIG5ld0JvYXJkW2FjdGlvbi50YXJnZXRJbmRleF1dID0gXHJcbiAgICBbbmV3Qm9hcmRbYWN0aW9uLnRhcmdldEluZGV4XSwgbmV3Qm9hcmRbc3RhdGUuZW1wdHlJbmRleF1dO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogbmV3Qm9hcmQuam9pbignLCcpLFxyXG4gICAgICBpc1Rlcm1pbmFsOiB0aGlzLmlzQm9hcmRHb2FsKG5ld0JvYXJkKSxcclxuICAgICAgYm9hcmQ6IG5ld0JvYXJkLFxyXG4gICAgICBlbXB0eUluZGV4OiBhY3Rpb24udGFyZ2V0SW5kZXhcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpc0dvYWwoc3RhdGU6IFB1enpsZVN0YXRlKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc3RhdGUua2V5ID09PSB0aGlzLmdvYWxTdGF0ZS5qb2luKCcsJyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGlzQm9hcmRHb2FsKGJvYXJkOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGJvYXJkLmV2ZXJ5KCh2YWwsIGlkeCkgPT4gdmFsID09PSB0aGlzLmdvYWxTdGF0ZVtpZHhdKTtcclxuICB9XHJcblxyXG4gIGdldENvc3Qoc3RhdGU6IFB1enpsZVN0YXRlLCBhY3Rpb246IFB1enpsZUFjdGlvbiwgbmV4dFN0YXRlOiBQdXp6bGVTdGF0ZSk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcblxyXG4gIC8vIEhldXLDrXN0aWNhOiBEaXN0w6JuY2lhIGRlIE1hbmhhdHRhblxyXG4gIGdldEhldXJpc3RpYyhzdGF0ZTogUHV6emxlU3RhdGUpOiBudW1iZXIge1xyXG4gICAgbGV0IGRpc3RhbmNlID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gc3RhdGUuYm9hcmRbaV07XHJcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCkgeyAvLyBOw6NvIGNvbnRhbW9zIG8gZXNwYcOnbyB2YXppb1xyXG4gICAgICAgIC8vIFBvc2nDp8OjbyBhdHVhbFxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBNYXRoLmZsb29yKGkgLyAzKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50Q29sID0gaSAlIDM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUG9zacOnw6NvIG9iamV0aXZvICh2YWxvciAtIDEsIHBvaXMgMSBlc3TDoSBubyDDrW5kaWNlIDApXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSB2YWx1ZSAtIDE7IC8vIEFzc3VtaW5kbyBvYmpldGl2byBbMSwyLDMsNCw1LDYsNyw4LDBdXHJcbiAgICAgICAgLy8gTm90YTogU2UgbyBvYmpldGl2byBmb3IgZGlmZXJlbnRlLCBwcmVjaXNhIGJ1c2NhciBvIMOtbmRpY2Ugbm8gYXJyYXkgZ29hbFN0YXRlXHJcbiAgICAgICAgLy8gTWFzIHBhcmEgbyBwYWRyw6NvIFsxLi44LCAwXSwgdmFsdWUgMSB2YWkgcGFyYSBpbmRleCAwLlxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHRhcmdldFJvdyA9IE1hdGguZmxvb3IodGFyZ2V0SW5kZXggLyAzKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRDb2wgPSB0YXJnZXRJbmRleCAlIDM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZGlzdGFuY2UgKz0gTWF0aC5hYnMoY3VycmVudFJvdyAtIHRhcmdldFJvdykgKyBNYXRoLmFicyhjdXJyZW50Q29sIC0gdGFyZ2V0Q29sKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiRWlnaHRQdXp6bGUiLCJnZXRBY3Rpb25zIiwic3RhdGUiLCJhY3Rpb25zIiwiZW1wdHlJbmRleCIsInNpemUiLCJyb3ciLCJNYXRoIiwiZmxvb3IiLCJjb2wiLCJwdXNoIiwibmFtZSIsImRpcmVjdGlvbiIsInRhcmdldEluZGV4IiwiZ2V0UmVzdWx0IiwiYWN0aW9uIiwibmV3Qm9hcmQiLCJib2FyZCIsImtleSIsImpvaW4iLCJpc1Rlcm1pbmFsIiwiaXNCb2FyZEdvYWwiLCJpc0dvYWwiLCJnb2FsU3RhdGUiLCJldmVyeSIsInZhbCIsImlkeCIsImdldENvc3QiLCJuZXh0U3RhdGUiLCJnZXRIZXVyaXN0aWMiLCJkaXN0YW5jZSIsImkiLCJ2YWx1ZSIsImN1cnJlbnRSb3ciLCJjdXJyZW50Q29sIiwidGFyZ2V0Um93IiwidGFyZ2V0Q29sIiwiYWJzIiwiY29uc3RydWN0b3IiLCJpbml0aWFsQm9hcmQiLCJpbml0aWFsU3RhdGUiLCJpbmRleE9mIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/ai/problems/EightPuzzle.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/ai/problems/TicTacToe.ts":
/*!******************************************!*\
  !*** ./src/lib/ai/problems/TicTacToe.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TicTacToe: () => (/* binding */ TicTacToe)\n/* harmony export */ });\nclass TicTacToe {\n    getActions(state) {\n        if (state.isTerminal) return [];\n        const actions = [];\n        for(let i = 0; i < 9; i++){\n            if (state.board[i] === null) {\n                actions.push({\n                    name: \"Place \".concat(state.playerTurn, \" at \").concat(i),\n                    index: i\n                });\n            }\n        }\n        return actions;\n    }\n    getResult(state, action) {\n        const newBoard = [\n            ...state.board\n        ];\n        newBoard[action.index] = state.playerTurn;\n        const nextPlayer = state.playerTurn === 'X' ? 'O' : 'X';\n        const winner = this.checkWinner(newBoard);\n        const isFull = !newBoard.includes(null);\n        return {\n            key: this.boardToString(newBoard),\n            isTerminal: winner !== null || isFull,\n            board: newBoard,\n            playerTurn: nextPlayer\n        };\n    }\n    isGoal(state) {\n        return state.isTerminal;\n    }\n    getCost(state, action, nextState) {\n        return 1; // Custo uniforme\n    }\n    getHeuristic(state) {\n        return 0; // Jogos pequenos geralmente não precisam de heurística complexa para busca completa\n    }\n    // Retorna utilidade para o jogador 'X' (Max)\n    // 1 = X ganhou, -1 = O ganhou, 0 = Empate\n    getUtility(state, player) {\n        const winner = this.checkWinner(state.board);\n        if (winner === 'X') return 1;\n        if (winner === 'O') return -1;\n        return 0;\n    }\n    checkWinner(board) {\n        const lines = [\n            [\n                0,\n                1,\n                2\n            ],\n            [\n                3,\n                4,\n                5\n            ],\n            [\n                6,\n                7,\n                8\n            ],\n            [\n                0,\n                3,\n                6\n            ],\n            [\n                1,\n                4,\n                7\n            ],\n            [\n                2,\n                5,\n                8\n            ],\n            [\n                0,\n                4,\n                8\n            ],\n            [\n                2,\n                4,\n                6\n            ] // Diagonais\n        ];\n        for (const [a, b, c] of lines){\n            if (board[a] && board[a] === board[b] && board[a] === board[c]) {\n                return board[a];\n            }\n        }\n        return null;\n    }\n    boardToString(board) {\n        return board.map((c)=>c || '-').join('');\n    }\n    constructor(){\n        this.initialState = {\n            key: '---------',\n            isTerminal: false,\n            board: Array(9).fill(null),\n            playerTurn: 'X'\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWkvcHJvYmxlbXMvVGljVGFjVG9lLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFXTyxNQUFNQTtJQVlYQyxXQUFXQyxLQUFxQixFQUFxQjtRQUNuRCxJQUFJQSxNQUFNQyxVQUFVLEVBQUUsT0FBTyxFQUFFO1FBRS9CLE1BQU1DLFVBQTZCLEVBQUU7UUFDckMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztZQUMxQixJQUFJSCxNQUFNSSxLQUFLLENBQUNELEVBQUUsS0FBSyxNQUFNO2dCQUMzQkQsUUFBUUcsSUFBSSxDQUFDO29CQUFFQyxNQUFNLFNBQWdDSCxPQUF2QkgsTUFBTU8sVUFBVSxFQUFDLFFBQVEsT0FBRko7b0JBQUtLLE9BQU9MO2dCQUFFO1lBQ3JFO1FBQ0Y7UUFDQSxPQUFPRDtJQUNUO0lBRUFPLFVBQVVULEtBQXFCLEVBQUVVLE1BQXVCLEVBQWtCO1FBQ3hFLE1BQU1DLFdBQVc7ZUFBSVgsTUFBTUksS0FBSztTQUFDO1FBQ2pDTyxRQUFRLENBQUNELE9BQU9GLEtBQUssQ0FBQyxHQUFHUixNQUFNTyxVQUFVO1FBRXpDLE1BQU1LLGFBQWFaLE1BQU1PLFVBQVUsS0FBSyxNQUFNLE1BQU07UUFDcEQsTUFBTU0sU0FBUyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0g7UUFDaEMsTUFBTUksU0FBUyxDQUFDSixTQUFTSyxRQUFRLENBQUM7UUFFbEMsT0FBTztZQUNMQyxLQUFLLElBQUksQ0FBQ0MsYUFBYSxDQUFDUDtZQUN4QlYsWUFBWVksV0FBVyxRQUFRRTtZQUMvQlgsT0FBT087WUFDUEosWUFBWUs7UUFDZDtJQUNGO0lBRUFPLE9BQU9uQixLQUFxQixFQUFXO1FBQ3JDLE9BQU9BLE1BQU1DLFVBQVU7SUFDekI7SUFFQW1CLFFBQVFwQixLQUFxQixFQUFFVSxNQUF1QixFQUFFVyxTQUF5QixFQUFVO1FBQ3pGLE9BQU8sR0FBRyxpQkFBaUI7SUFDN0I7SUFFQUMsYUFBYXRCLEtBQXFCLEVBQVU7UUFDMUMsT0FBTyxHQUFHLG9GQUFvRjtJQUNoRztJQUVBLDZDQUE2QztJQUM3QywwQ0FBMEM7SUFDMUN1QixXQUFXdkIsS0FBcUIsRUFBRXdCLE1BQWMsRUFBVTtRQUN4RCxNQUFNWCxTQUFTLElBQUksQ0FBQ0MsV0FBVyxDQUFDZCxNQUFNSSxLQUFLO1FBQzNDLElBQUlTLFdBQVcsS0FBSyxPQUFPO1FBQzNCLElBQUlBLFdBQVcsS0FBSyxPQUFPLENBQUM7UUFDNUIsT0FBTztJQUNUO0lBRVFDLFlBQVlWLEtBQXdCLEVBQWlCO1FBQzNELE1BQU1xQixRQUFRO1lBQ1o7Z0JBQUM7Z0JBQUc7Z0JBQUc7YUFBRTtZQUFFO2dCQUFDO2dCQUFHO2dCQUFHO2FBQUU7WUFBRTtnQkFBQztnQkFBRztnQkFBRzthQUFFO1lBQy9CO2dCQUFDO2dCQUFHO2dCQUFHO2FBQUU7WUFBRTtnQkFBQztnQkFBRztnQkFBRzthQUFFO1lBQUU7Z0JBQUM7Z0JBQUc7Z0JBQUc7YUFBRTtZQUMvQjtnQkFBQztnQkFBRztnQkFBRzthQUFFO1lBQUU7Z0JBQUM7Z0JBQUc7Z0JBQUc7YUFBRSxDQUFhLFlBQVk7U0FDOUM7UUFFRCxLQUFLLE1BQU0sQ0FBQ0MsR0FBR0MsR0FBR0MsRUFBRSxJQUFJSCxNQUFPO1lBQzdCLElBQUlyQixLQUFLLENBQUNzQixFQUFFLElBQUl0QixLQUFLLENBQUNzQixFQUFFLEtBQUt0QixLQUFLLENBQUN1QixFQUFFLElBQUl2QixLQUFLLENBQUNzQixFQUFFLEtBQUt0QixLQUFLLENBQUN3QixFQUFFLEVBQUU7Z0JBQzlELE9BQU94QixLQUFLLENBQUNzQixFQUFFO1lBQ2pCO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFFUVIsY0FBY2QsS0FBd0IsRUFBVTtRQUN0RCxPQUFPQSxNQUFNeUIsR0FBRyxDQUFDRCxDQUFBQSxJQUFLQSxLQUFLLEtBQUtFLElBQUksQ0FBQztJQUN2QztJQTNFQUMsYUFBYztRQUNaLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1lBQ2xCZixLQUFLO1lBQ0xoQixZQUFZO1lBQ1pHLE9BQU82QixNQUFNLEdBQUdDLElBQUksQ0FBQztZQUNyQjNCLFlBQVk7UUFDZDtJQUNGO0FBcUVGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGJyYW5kXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcR2l0SHViXFxhbGdvcml0aG1fSUFcXHNyY1xcbGliXFxhaVxccHJvYmxlbXNcXFRpY1RhY1RvZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm9ibGVtLCBTdGF0ZSwgQWN0aW9uIH0gZnJvbSAnLi4vY29yZS90eXBlcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRpY1RhY1RvZVN0YXRlIGV4dGVuZHMgU3RhdGUge1xyXG4gIGJvYXJkOiAoc3RyaW5nIHwgbnVsbClbXTsgLy8gQXJyYXkgZGUgOSBwb3Npw6fDtWVzXHJcbiAgcGxheWVyVHVybjogJ1gnIHwgJ08nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRpY1RhY1RvZUFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XHJcbiAgaW5kZXg6IG51bWJlcjsgLy8gMC04XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUaWNUYWNUb2UgaW1wbGVtZW50cyBQcm9ibGVtPFRpY1RhY1RvZVN0YXRlLCBUaWNUYWNUb2VBY3Rpb24+IHtcclxuICBwdWJsaWMgaW5pdGlhbFN0YXRlOiBUaWNUYWNUb2VTdGF0ZTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IHtcclxuICAgICAga2V5OiAnLS0tLS0tLS0tJywgLy8gUmVwcmVzZW50YcOnw6NvIHZhemlhXHJcbiAgICAgIGlzVGVybWluYWw6IGZhbHNlLFxyXG4gICAgICBib2FyZDogQXJyYXkoOSkuZmlsbChudWxsKSxcclxuICAgICAgcGxheWVyVHVybjogJ1gnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0QWN0aW9ucyhzdGF0ZTogVGljVGFjVG9lU3RhdGUpOiBUaWNUYWNUb2VBY3Rpb25bXSB7XHJcbiAgICBpZiAoc3RhdGUuaXNUZXJtaW5hbCkgcmV0dXJuIFtdO1xyXG4gICAgXHJcbiAgICBjb25zdCBhY3Rpb25zOiBUaWNUYWNUb2VBY3Rpb25bXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcclxuICAgICAgaWYgKHN0YXRlLmJvYXJkW2ldID09PSBudWxsKSB7XHJcbiAgICAgICAgYWN0aW9ucy5wdXNoKHsgbmFtZTogYFBsYWNlICR7c3RhdGUucGxheWVyVHVybn0gYXQgJHtpfWAsIGluZGV4OiBpIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aW9ucztcclxuICB9XHJcblxyXG4gIGdldFJlc3VsdChzdGF0ZTogVGljVGFjVG9lU3RhdGUsIGFjdGlvbjogVGljVGFjVG9lQWN0aW9uKTogVGljVGFjVG9lU3RhdGUge1xyXG4gICAgY29uc3QgbmV3Qm9hcmQgPSBbLi4uc3RhdGUuYm9hcmRdO1xyXG4gICAgbmV3Qm9hcmRbYWN0aW9uLmluZGV4XSA9IHN0YXRlLnBsYXllclR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IG5leHRQbGF5ZXIgPSBzdGF0ZS5wbGF5ZXJUdXJuID09PSAnWCcgPyAnTycgOiAnWCc7XHJcbiAgICBjb25zdCB3aW5uZXIgPSB0aGlzLmNoZWNrV2lubmVyKG5ld0JvYXJkKTtcclxuICAgIGNvbnN0IGlzRnVsbCA9ICFuZXdCb2FyZC5pbmNsdWRlcyhudWxsKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiB0aGlzLmJvYXJkVG9TdHJpbmcobmV3Qm9hcmQpLFxyXG4gICAgICBpc1Rlcm1pbmFsOiB3aW5uZXIgIT09IG51bGwgfHwgaXNGdWxsLFxyXG4gICAgICBib2FyZDogbmV3Qm9hcmQsXHJcbiAgICAgIHBsYXllclR1cm46IG5leHRQbGF5ZXJcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpc0dvYWwoc3RhdGU6IFRpY1RhY1RvZVN0YXRlKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc3RhdGUuaXNUZXJtaW5hbDtcclxuICB9XHJcblxyXG4gIGdldENvc3Qoc3RhdGU6IFRpY1RhY1RvZVN0YXRlLCBhY3Rpb246IFRpY1RhY1RvZUFjdGlvbiwgbmV4dFN0YXRlOiBUaWNUYWNUb2VTdGF0ZSk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gMTsgLy8gQ3VzdG8gdW5pZm9ybWVcclxuICB9XHJcblxyXG4gIGdldEhldXJpc3RpYyhzdGF0ZTogVGljVGFjVG9lU3RhdGUpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIDA7IC8vIEpvZ29zIHBlcXVlbm9zIGdlcmFsbWVudGUgbsOjbyBwcmVjaXNhbSBkZSBoZXVyw61zdGljYSBjb21wbGV4YSBwYXJhIGJ1c2NhIGNvbXBsZXRhXHJcbiAgfVxyXG5cclxuICAvLyBSZXRvcm5hIHV0aWxpZGFkZSBwYXJhIG8gam9nYWRvciAnWCcgKE1heClcclxuICAvLyAxID0gWCBnYW5ob3UsIC0xID0gTyBnYW5ob3UsIDAgPSBFbXBhdGVcclxuICBnZXRVdGlsaXR5KHN0YXRlOiBUaWNUYWNUb2VTdGF0ZSwgcGxheWVyOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgY29uc3Qgd2lubmVyID0gdGhpcy5jaGVja1dpbm5lcihzdGF0ZS5ib2FyZCk7XHJcbiAgICBpZiAod2lubmVyID09PSAnWCcpIHJldHVybiAxO1xyXG4gICAgaWYgKHdpbm5lciA9PT0gJ08nKSByZXR1cm4gLTE7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2hlY2tXaW5uZXIoYm9hcmQ6IChzdHJpbmcgfCBudWxsKVtdKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICBjb25zdCBsaW5lcyA9IFtcclxuICAgICAgWzAsIDEsIDJdLCBbMywgNCwgNV0sIFs2LCA3LCA4XSwgLy8gTGluaGFzXHJcbiAgICAgIFswLCAzLCA2XSwgWzEsIDQsIDddLCBbMiwgNSwgOF0sIC8vIENvbHVuYXNcclxuICAgICAgWzAsIDQsIDhdLCBbMiwgNCwgNl0gICAgICAgICAgICAgLy8gRGlhZ29uYWlzXHJcbiAgICBdO1xyXG5cclxuICAgIGZvciAoY29uc3QgW2EsIGIsIGNdIG9mIGxpbmVzKSB7XHJcbiAgICAgIGlmIChib2FyZFthXSAmJiBib2FyZFthXSA9PT0gYm9hcmRbYl0gJiYgYm9hcmRbYV0gPT09IGJvYXJkW2NdKSB7XHJcbiAgICAgICAgcmV0dXJuIGJvYXJkW2FdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYm9hcmRUb1N0cmluZyhib2FyZDogKHN0cmluZyB8IG51bGwpW10pOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGJvYXJkLm1hcChjID0+IGMgfHwgJy0nKS5qb2luKCcnKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbIlRpY1RhY1RvZSIsImdldEFjdGlvbnMiLCJzdGF0ZSIsImlzVGVybWluYWwiLCJhY3Rpb25zIiwiaSIsImJvYXJkIiwicHVzaCIsIm5hbWUiLCJwbGF5ZXJUdXJuIiwiaW5kZXgiLCJnZXRSZXN1bHQiLCJhY3Rpb24iLCJuZXdCb2FyZCIsIm5leHRQbGF5ZXIiLCJ3aW5uZXIiLCJjaGVja1dpbm5lciIsImlzRnVsbCIsImluY2x1ZGVzIiwia2V5IiwiYm9hcmRUb1N0cmluZyIsImlzR29hbCIsImdldENvc3QiLCJuZXh0U3RhdGUiLCJnZXRIZXVyaXN0aWMiLCJnZXRVdGlsaXR5IiwicGxheWVyIiwibGluZXMiLCJhIiwiYiIsImMiLCJtYXAiLCJqb2luIiwiY29uc3RydWN0b3IiLCJpbml0aWFsU3RhdGUiLCJBcnJheSIsImZpbGwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/ai/problems/TicTacToe.ts\n"));

/***/ })

});