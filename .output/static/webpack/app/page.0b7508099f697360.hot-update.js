"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/gameStore.ts":
/*!********************************!*\
  !*** ./src/store/gameStore.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameStore: () => (/* binding */ useGameStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n\n// O estado inicial agora é uma árvore com apenas um nó.\nconst initialTree = {\n    id: 'root',\n    name: 'Start',\n    children: []\n};\nconst useGameStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set)=>({\n        algorithm: null,\n        problemType: 'custom',\n        depth: 0,\n        nodesExplored: 0,\n        isSimulating: false,\n        resetTrigger: 0,\n        tree: initialTree,\n        admissibilityViolations: [],\n        goalState: [\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            0\n        ],\n        // Default visual settings\n        maxNodeShape: 'triangle',\n        minNodeShape: 'circle',\n        nodeViewMode: 'shape',\n        setAlgorithm: (algo)=>set({\n                algorithm: algo,\n                admissibilityViolations: []\n            }),\n        setProblemType: (type)=>set((state)=>{\n                const newNodeViewMode = type === 'custom' ? 'shape' : 'game';\n                let newTree;\n                let newGoalState;\n                if (type === 'tictactoe') {\n                    newTree = {\n                        id: 'root',\n                        name: 'Start',\n                        children: [],\n                        boardState: Array(9).fill(null)\n                    };\n                    newGoalState = null;\n                } else if (type === '8puzzle') {\n                    newTree = {\n                        id: 'root',\n                        name: 'Start',\n                        children: [],\n                        boardState: [\n                            1,\n                            2,\n                            3,\n                            4,\n                            5,\n                            6,\n                            7,\n                            8,\n                            0\n                        ]\n                    };\n                    newGoalState = [\n                        1,\n                        2,\n                        3,\n                        4,\n                        5,\n                        6,\n                        7,\n                        8,\n                        0\n                    ];\n                } else {\n                    newTree = {\n                        id: 'root',\n                        name: 'Start',\n                        children: []\n                    };\n                    newGoalState = null;\n                }\n                return {\n                    problemType: type,\n                    tree: newTree,\n                    algorithm: null,\n                    resetTrigger: state.resetTrigger + 1,\n                    goalState: newGoalState,\n                    nodeViewMode: newNodeViewMode,\n                    admissibilityViolations: [],\n                    nodesExplored: 0,\n                    isSimulating: false\n                };\n            }),\n        setDepth: (depth)=>set({\n                depth\n            }),\n        incrementNodes: ()=>set((state)=>({\n                    nodesExplored: state.nodesExplored + 1\n                })),\n        toggleSimulation: ()=>set((state)=>({\n                    isSimulating: !state.isSimulating\n                })),\n        reset: ()=>set((state)=>({\n                    depth: 0,\n                    nodesExplored: 0,\n                    isSimulating: false,\n                    resetTrigger: state.resetTrigger + 1,\n                    admissibilityViolations: []\n                })),\n        setNodesExplored: (count)=>set({\n                nodesExplored: count\n            }),\n        setMaxNodeShape: (shape)=>set({\n                maxNodeShape: shape\n            }),\n        setMinNodeShape: (shape)=>set({\n                minNodeShape: shape\n            }),\n        setNodeViewMode: (mode)=>set({\n                nodeViewMode: mode\n            }),\n        setGoalState: (state)=>set({\n                goalState: state\n            }),\n        setAdmissibilityViolations: (ids)=>set({\n                admissibilityViolations: ids\n            }),\n        updateTree: (newTree)=>set({\n                tree: newTree\n            }),\n        addNode: (parentId, newNode)=>set((state)=>{\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const addRecursive = (node)=>{\n                    if (node.id === parentId) {\n                        node.children.push(newNode);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (addRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                addRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            }),\n        removeNode: (nodeId)=>set((state)=>{\n                if (nodeId === 'root') return state;\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const removeRecursive = (node)=>{\n                    const index = node.children.findIndex((c)=>c.id === nodeId);\n                    if (index !== -1) {\n                        node.children.splice(index, 1);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (removeRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                removeRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            }),\n        updateNodeAttributes: (nodeId, attributes)=>set((state)=>{\n                const newTree = JSON.parse(JSON.stringify(state.tree));\n                const updateRecursive = (node)=>{\n                    if (node.id === nodeId) {\n                        Object.assign(node, attributes);\n                        return true;\n                    }\n                    for (const child of node.children){\n                        if (updateRecursive(child)) return true;\n                    }\n                    return false;\n                };\n                updateRecursive(newTree);\n                return {\n                    tree: newTree\n                };\n            })\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9nYW1lU3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0M7QUFtRWhDLHdEQUF3RDtBQUN4RCxNQUFNQyxjQUE4QjtJQUNsQ0MsSUFBSTtJQUNKQyxNQUFNO0lBQ05DLFVBQVUsRUFBRTtBQUNkO0FBRU8sTUFBTUMsZUFBZUwsK0NBQU1BLENBQVksQ0FBQ00sTUFBUztRQUN0REMsV0FBVztRQUNYQyxhQUFhO1FBQ2JDLE9BQU87UUFDUEMsZUFBZTtRQUNmQyxjQUFjO1FBQ2RDLGNBQWM7UUFDZEMsTUFBTVo7UUFDTmEseUJBQXlCLEVBQUU7UUFDM0JDLFdBQVc7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUV0QywwQkFBMEI7UUFDMUJDLGNBQWM7UUFDZEMsY0FBYztRQUNkQyxjQUFjO1FBRWRDLGNBQWMsQ0FBQ0MsT0FBU2QsSUFBSTtnQkFBRUMsV0FBV2E7Z0JBQU1OLHlCQUF5QixFQUFFO1lBQUM7UUFFM0VPLGdCQUFnQixDQUFDQyxPQUFTaEIsSUFBSSxDQUFDaUI7Z0JBQzdCLE1BQU1DLGtCQUFrQkYsU0FBUyxXQUFXLFVBQVU7Z0JBQ3RELElBQUlHO2dCQUNKLElBQUlDO2dCQUVKLElBQUlKLFNBQVMsYUFBYTtvQkFDeEJHLFVBQVU7d0JBQUV2QixJQUFJO3dCQUFRQyxNQUFNO3dCQUFTQyxVQUFVLEVBQUU7d0JBQUV1QixZQUFZQyxNQUFNLEdBQUdDLElBQUksQ0FBQztvQkFBTTtvQkFDckZILGVBQWU7Z0JBQ2pCLE9BQU8sSUFBSUosU0FBUyxXQUFXO29CQUM3QkcsVUFBVTt3QkFBRXZCLElBQUk7d0JBQVFDLE1BQU07d0JBQVNDLFVBQVUsRUFBRTt3QkFBRXVCLFlBQVk7NEJBQUM7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUc7eUJBQUU7b0JBQUM7b0JBQzdGRCxlQUFlO3dCQUFDO3dCQUFHO3dCQUFHO3dCQUFHO3dCQUFHO3dCQUFHO3dCQUFHO3dCQUFHO3dCQUFHO3FCQUFFO2dCQUM1QyxPQUFPO29CQUNMRCxVQUFVO3dCQUFFdkIsSUFBSTt3QkFBUUMsTUFBTTt3QkFBU0MsVUFBVSxFQUFFO29CQUFDO29CQUNwRHNCLGVBQWU7Z0JBQ2pCO2dCQUVBLE9BQU87b0JBQ0xsQixhQUFhYztvQkFDYlQsTUFBTVk7b0JBQ05sQixXQUFXO29CQUNYSyxjQUFjVyxNQUFNWCxZQUFZLEdBQUc7b0JBQ25DRyxXQUFXVztvQkFDWFIsY0FBY007b0JBQ2RWLHlCQUF5QixFQUFFO29CQUMzQkosZUFBZTtvQkFDZkMsY0FBYztnQkFDaEI7WUFDRjtRQUVBbUIsVUFBVSxDQUFDckIsUUFBVUgsSUFBSTtnQkFBRUc7WUFBTTtRQUNqQ3NCLGdCQUFnQixJQUFNekIsSUFBSSxDQUFDaUIsUUFBVztvQkFBRWIsZUFBZWEsTUFBTWIsYUFBYSxHQUFHO2dCQUFFO1FBQy9Fc0Isa0JBQWtCLElBQU0xQixJQUFJLENBQUNpQixRQUFXO29CQUFFWixjQUFjLENBQUNZLE1BQU1aLFlBQVk7Z0JBQUM7UUFFNUVzQixPQUFPLElBQU0zQixJQUFJLENBQUNpQixRQUFXO29CQUMzQmQsT0FBTztvQkFDUEMsZUFBZTtvQkFDZkMsY0FBYztvQkFDZEMsY0FBY1csTUFBTVgsWUFBWSxHQUFHO29CQUNuQ0UseUJBQXlCLEVBQUU7Z0JBQzdCO1FBRUFvQixrQkFBa0IsQ0FBQ0MsUUFBVTdCLElBQUk7Z0JBQUVJLGVBQWV5QjtZQUFNO1FBRXhEQyxpQkFBaUIsQ0FBQ0MsUUFBVS9CLElBQUk7Z0JBQUVVLGNBQWNxQjtZQUFNO1FBQ3REQyxpQkFBaUIsQ0FBQ0QsUUFBVS9CLElBQUk7Z0JBQUVXLGNBQWNvQjtZQUFNO1FBQ3RERSxpQkFBaUIsQ0FBQ0MsT0FBU2xDLElBQUk7Z0JBQUVZLGNBQWNzQjtZQUFLO1FBQ3BEQyxjQUFjLENBQUNsQixRQUFVakIsSUFBSTtnQkFBRVMsV0FBV1E7WUFBTTtRQUVoRG1CLDRCQUE0QixDQUFDQyxNQUFRckMsSUFBSTtnQkFBRVEseUJBQXlCNkI7WUFBSTtRQUV4RUMsWUFBWSxDQUFDbkIsVUFBWW5CLElBQUk7Z0JBQUVPLE1BQU1ZO1lBQVE7UUFFN0NvQixTQUFTLENBQUNDLFVBQVVDLFVBQVl6QyxJQUFJLENBQUNpQjtnQkFDbkMsTUFBTUUsVUFBVXVCLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDM0IsTUFBTVYsSUFBSTtnQkFDcEQsTUFBTXNDLGVBQWUsQ0FBQ0M7b0JBQ3BCLElBQUlBLEtBQUtsRCxFQUFFLEtBQUs0QyxVQUFVO3dCQUN4Qk0sS0FBS2hELFFBQVEsQ0FBQ2lELElBQUksQ0FBQ047d0JBQ25CLE9BQU87b0JBQ1Q7b0JBQ0EsS0FBSyxNQUFNTyxTQUFTRixLQUFLaEQsUUFBUSxDQUFFO3dCQUNqQyxJQUFJK0MsYUFBYUcsUUFBUSxPQUFPO29CQUNsQztvQkFDQSxPQUFPO2dCQUNUO2dCQUNBSCxhQUFhMUI7Z0JBQ2IsT0FBTztvQkFBRVosTUFBTVk7Z0JBQVE7WUFDekI7UUFFQThCLFlBQVksQ0FBQ0MsU0FBV2xELElBQUksQ0FBQ2lCO2dCQUMzQixJQUFJaUMsV0FBVyxRQUFRLE9BQU9qQztnQkFDOUIsTUFBTUUsVUFBVXVCLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDM0IsTUFBTVYsSUFBSTtnQkFDcEQsTUFBTTRDLGtCQUFrQixDQUFDTDtvQkFDdkIsTUFBTU0sUUFBUU4sS0FBS2hELFFBQVEsQ0FBQ3VELFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRTFELEVBQUUsS0FBS3NEO29CQUNwRCxJQUFJRSxVQUFVLENBQUMsR0FBRzt3QkFDaEJOLEtBQUtoRCxRQUFRLENBQUN5RCxNQUFNLENBQUNILE9BQU87d0JBQzVCLE9BQU87b0JBQ1Q7b0JBQ0EsS0FBSyxNQUFNSixTQUFTRixLQUFLaEQsUUFBUSxDQUFFO3dCQUNqQyxJQUFJcUQsZ0JBQWdCSCxRQUFRLE9BQU87b0JBQ3JDO29CQUNBLE9BQU87Z0JBQ1Q7Z0JBQ0FHLGdCQUFnQmhDO2dCQUNoQixPQUFPO29CQUFFWixNQUFNWTtnQkFBUTtZQUN6QjtRQUVBcUMsc0JBQXNCLENBQUNOLFFBQVFPLGFBQWV6RCxJQUFJLENBQUNpQjtnQkFDakQsTUFBTUUsVUFBVXVCLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDM0IsTUFBTVYsSUFBSTtnQkFDcEQsTUFBTW1ELGtCQUFrQixDQUFDWjtvQkFDdkIsSUFBSUEsS0FBS2xELEVBQUUsS0FBS3NELFFBQVE7d0JBQ3RCUyxPQUFPQyxNQUFNLENBQUNkLE1BQU1XO3dCQUNwQixPQUFPO29CQUNUO29CQUNBLEtBQUssTUFBTVQsU0FBU0YsS0FBS2hELFFBQVEsQ0FBRTt3QkFDakMsSUFBSTRELGdCQUFnQlYsUUFBUSxPQUFPO29CQUNyQztvQkFDQSxPQUFPO2dCQUNUO2dCQUNBVSxnQkFBZ0J2QztnQkFDaEIsT0FBTztvQkFBRVosTUFBTVk7Z0JBQVE7WUFDekI7SUFDRixJQUFHIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGJyYW5kXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcR2l0SHViXFxhbGdvcml0aG1fSUFcXHNyY1xcc3RvcmVcXGdhbWVTdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJ1xyXG5cclxuZXhwb3J0IHR5cGUgQWxnb3JpdGhtVHlwZSA9XHJcbiAgfCAnYmZzJyB8ICdkZnMnIHwgJ2lkcycgfCAndWNzJyB8ICdncmVlZHknIHwgJ2FzdGFyJyB8ICdpZGFzdGFyJ1xyXG4gIHwgJ21pbmltYXgnIHwgJ2FscGhhLWJldGEnIHwgJ21jdHMnXHJcbiAgfCBudWxsO1xyXG5cclxuZXhwb3J0IHR5cGUgUHJvYmxlbVR5cGUgPSAnY3VzdG9tJyB8ICd0aWN0YWN0b2UnIHwgJzhwdXp6bGUnO1xyXG5cclxuZXhwb3J0IHR5cGUgTm9kZVNoYXBlID0gJ2NpcmNsZScgfCAndHJpYW5nbGUnIHwgJ3NxdWFyZSc7XHJcblxyXG5leHBvcnQgdHlwZSBOb2RlVmlld01vZGUgPSAnc2hhcGUnIHwgJ2dhbWUnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21UcmVlTm9kZSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgdmFsdWU/OiBudW1iZXI7IC8vIEhldXLDrXN0aWNhIG91IFV0aWxpZGFkZVxyXG4gIGNoaWxkcmVuOiBDdXN0b21UcmVlTm9kZVtdO1xyXG4gIGlzR29hbD86IGJvb2xlYW47XHJcbiAgY29zdFRvUGFyZW50PzogbnVtYmVyOyAvLyBDdXN0byBkYSBhcmVzdGFcclxuICBib2FyZFN0YXRlPzogYW55OyAvLyBQYXJhIFRpY1RhY1RvZSBvdSA4LVB1enpsZVxyXG59XHJcblxyXG5pbnRlcmZhY2UgR2FtZVN0YXRlIHtcclxuICBhbGdvcml0aG06IEFsZ29yaXRobVR5cGVcclxuICBwcm9ibGVtVHlwZTogUHJvYmxlbVR5cGVcclxuICBkZXB0aDogbnVtYmVyXHJcbiAgbm9kZXNFeHBsb3JlZDogbnVtYmVyXHJcbiAgaXNTaW11bGF0aW5nOiBib29sZWFuXHJcbiAgcmVzZXRUcmlnZ2VyOiBudW1iZXJcclxuXHJcbiAgLy8gQ29uZmlndXJhw6fDtWVzIFZpc3VhaXNcclxuICBtYXhOb2RlU2hhcGU6IE5vZGVTaGFwZVxyXG4gIG1pbk5vZGVTaGFwZTogTm9kZVNoYXBlXHJcbiAgbm9kZVZpZXdNb2RlOiBOb2RlVmlld01vZGVcclxuICBnb2FsU3RhdGU6IGFueSB8IG51bGxcclxuXHJcbiAgLy8gSURzIGRlIG7Ds3MgcXVlIHZpb2xhbSBhIGFkbWlzc2liaWxpZGFkZVxyXG4gIGFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiBzdHJpbmdbXVxyXG5cclxuICAvLyBFc3RhZG8gZGEgw4Fydm9yZSBDdXN0b21pemFkYVxyXG4gIHRyZWU6IEN1c3RvbVRyZWVOb2RlXHJcblxyXG4gIHNldEFsZ29yaXRobTogKGFsZ286IEFsZ29yaXRobVR5cGUpID0+IHZvaWRcclxuICBzZXRQcm9ibGVtVHlwZTogKHR5cGU6IFByb2JsZW1UeXBlKSA9PiB2b2lkXHJcbiAgc2V0RGVwdGg6IChkZXB0aDogbnVtYmVyKSA9PiB2b2lkXHJcbiAgaW5jcmVtZW50Tm9kZXM6ICgpID0+IHZvaWRcclxuICB0b2dnbGVTaW11bGF0aW9uOiAoKSA9PiB2b2lkXHJcbiAgcmVzZXQ6ICgpID0+IHZvaWRcclxuICBcclxuICAvLyBBw6fDtWVzIFZpc3VhaXNcclxuICBzZXRNYXhOb2RlU2hhcGU6IChzaGFwZTogTm9kZVNoYXBlKSA9PiB2b2lkXHJcbiAgc2V0TWluTm9kZVNoYXBlOiAoc2hhcGU6IE5vZGVTaGFwZSkgPT4gdm9pZFxyXG4gIHNldE5vZGVWaWV3TW9kZTogKG1vZGU6IE5vZGVWaWV3TW9kZSkgPT4gdm9pZFxyXG4gIHNldEdvYWxTdGF0ZTogKHN0YXRlOiBhbnkpID0+IHZvaWRcclxuXHJcbiAgLy8gQcOnw7VlcyBkZSBBZG1pc3NpYmlsaWRhZGVcclxuICBzZXRBZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogKGlkczogc3RyaW5nW10pID0+IHZvaWRcclxuXHJcbiAgLy8gQcOnw7VlcyBkZSBFZGnDp8OjbyBkYSDDgXJ2b3JlXHJcbiAgdXBkYXRlVHJlZTogKG5ld1RyZWU6IEN1c3RvbVRyZWVOb2RlKSA9PiB2b2lkXHJcbiAgYWRkTm9kZTogKHBhcmVudElkOiBzdHJpbmcsIG5vZGU6IEN1c3RvbVRyZWVOb2RlKSA9PiB2b2lkXHJcbiAgcmVtb3ZlTm9kZTogKG5vZGVJZDogc3RyaW5nKSA9PiB2b2lkXHJcbiAgdXBkYXRlTm9kZUF0dHJpYnV0ZXM6IChub2RlSWQ6IHN0cmluZywgYXR0cmlidXRlczogUGFydGlhbDxDdXN0b21UcmVlTm9kZT4pID0+IHZvaWRcclxuICBzZXROb2Rlc0V4cGxvcmVkOiAoY291bnQ6IG51bWJlcikgPT4gdm9pZFxyXG59XHJcblxyXG4vLyBPIGVzdGFkbyBpbmljaWFsIGFnb3JhIMOpIHVtYSDDoXJ2b3JlIGNvbSBhcGVuYXMgdW0gbsOzLlxyXG5jb25zdCBpbml0aWFsVHJlZTogQ3VzdG9tVHJlZU5vZGUgPSB7XHJcbiAgaWQ6ICdyb290JyxcclxuICBuYW1lOiAnU3RhcnQnLFxyXG4gIGNoaWxkcmVuOiBbXSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VHYW1lU3RvcmUgPSBjcmVhdGU8R2FtZVN0YXRlPigoc2V0KSA9PiAoe1xyXG4gIGFsZ29yaXRobTogbnVsbCxcclxuICBwcm9ibGVtVHlwZTogJ2N1c3RvbScsXHJcbiAgZGVwdGg6IDAsXHJcbiAgbm9kZXNFeHBsb3JlZDogMCxcclxuICBpc1NpbXVsYXRpbmc6IGZhbHNlLFxyXG4gIHJlc2V0VHJpZ2dlcjogMCxcclxuICB0cmVlOiBpbml0aWFsVHJlZSxcclxuICBhZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogW10sXHJcbiAgZ29hbFN0YXRlOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgMF0sXHJcblxyXG4gIC8vIERlZmF1bHQgdmlzdWFsIHNldHRpbmdzXHJcbiAgbWF4Tm9kZVNoYXBlOiAndHJpYW5nbGUnLFxyXG4gIG1pbk5vZGVTaGFwZTogJ2NpcmNsZScsXHJcbiAgbm9kZVZpZXdNb2RlOiAnc2hhcGUnLFxyXG5cclxuICBzZXRBbGdvcml0aG06IChhbGdvKSA9PiBzZXQoeyBhbGdvcml0aG06IGFsZ28sIGFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiBbXSB9KSxcclxuICBcclxuICBzZXRQcm9ibGVtVHlwZTogKHR5cGUpID0+IHNldCgoc3RhdGUpID0+IHtcclxuICAgIGNvbnN0IG5ld05vZGVWaWV3TW9kZSA9IHR5cGUgPT09ICdjdXN0b20nID8gJ3NoYXBlJyA6ICdnYW1lJztcclxuICAgIGxldCBuZXdUcmVlOiBDdXN0b21UcmVlTm9kZTtcclxuICAgIGxldCBuZXdHb2FsU3RhdGU6IGFueTtcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ3RpY3RhY3RvZScpIHtcclxuICAgICAgbmV3VHJlZSA9IHsgaWQ6ICdyb290JywgbmFtZTogJ1N0YXJ0JywgY2hpbGRyZW46IFtdLCBib2FyZFN0YXRlOiBBcnJheSg5KS5maWxsKG51bGwpIH07XHJcbiAgICAgIG5ld0dvYWxTdGF0ZSA9IG51bGw7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICc4cHV6emxlJykge1xyXG4gICAgICBuZXdUcmVlID0geyBpZDogJ3Jvb3QnLCBuYW1lOiAnU3RhcnQnLCBjaGlsZHJlbjogW10sIGJvYXJkU3RhdGU6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAwXSB9O1xyXG4gICAgICBuZXdHb2FsU3RhdGUgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgMF07XHJcbiAgICB9IGVsc2UgeyAvLyBjdXN0b21cclxuICAgICAgbmV3VHJlZSA9IHsgaWQ6ICdyb290JywgbmFtZTogJ1N0YXJ0JywgY2hpbGRyZW46IFtdIH07XHJcbiAgICAgIG5ld0dvYWxTdGF0ZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgXHJcbiAgICAgIHByb2JsZW1UeXBlOiB0eXBlLCBcclxuICAgICAgdHJlZTogbmV3VHJlZSxcclxuICAgICAgYWxnb3JpdGhtOiBudWxsLCAvLyBGb3LDp2EgbyB1c3XDoXJpbyBhIHJlLXNlbGVjaW9uYXIgbyBhbGdvcml0bW9cclxuICAgICAgcmVzZXRUcmlnZ2VyOiBzdGF0ZS5yZXNldFRyaWdnZXIgKyAxLCBcclxuICAgICAgZ29hbFN0YXRlOiBuZXdHb2FsU3RhdGUsXHJcbiAgICAgIG5vZGVWaWV3TW9kZTogbmV3Tm9kZVZpZXdNb2RlLFxyXG4gICAgICBhZG1pc3NpYmlsaXR5VmlvbGF0aW9uczogW10sXHJcbiAgICAgIG5vZGVzRXhwbG9yZWQ6IDAsXHJcbiAgICAgIGlzU2ltdWxhdGluZzogZmFsc2UsXHJcbiAgICB9O1xyXG4gIH0pLFxyXG5cclxuICBzZXREZXB0aDogKGRlcHRoKSA9PiBzZXQoeyBkZXB0aCB9KSxcclxuICBpbmNyZW1lbnROb2RlczogKCkgPT4gc2V0KChzdGF0ZSkgPT4gKHsgbm9kZXNFeHBsb3JlZDogc3RhdGUubm9kZXNFeHBsb3JlZCArIDEgfSkpLFxyXG4gIHRvZ2dsZVNpbXVsYXRpb246ICgpID0+IHNldCgoc3RhdGUpID0+ICh7IGlzU2ltdWxhdGluZzogIXN0YXRlLmlzU2ltdWxhdGluZyB9KSksXHJcbiAgXHJcbiAgcmVzZXQ6ICgpID0+IHNldCgoc3RhdGUpID0+ICh7IFxyXG4gICAgZGVwdGg6IDAsIFxyXG4gICAgbm9kZXNFeHBsb3JlZDogMCwgXHJcbiAgICBpc1NpbXVsYXRpbmc6IGZhbHNlLFxyXG4gICAgcmVzZXRUcmlnZ2VyOiBzdGF0ZS5yZXNldFRyaWdnZXIgKyAxLFxyXG4gICAgYWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IFtdXHJcbiAgfSkpLFxyXG4gIFxyXG4gIHNldE5vZGVzRXhwbG9yZWQ6IChjb3VudCkgPT4gc2V0KHsgbm9kZXNFeHBsb3JlZDogY291bnQgfSksXHJcblxyXG4gIHNldE1heE5vZGVTaGFwZTogKHNoYXBlKSA9PiBzZXQoeyBtYXhOb2RlU2hhcGU6IHNoYXBlIH0pLFxyXG4gIHNldE1pbk5vZGVTaGFwZTogKHNoYXBlKSA9PiBzZXQoeyBtaW5Ob2RlU2hhcGU6IHNoYXBlIH0pLFxyXG4gIHNldE5vZGVWaWV3TW9kZTogKG1vZGUpID0+IHNldCh7IG5vZGVWaWV3TW9kZTogbW9kZSB9KSxcclxuICBzZXRHb2FsU3RhdGU6IChzdGF0ZSkgPT4gc2V0KHsgZ29hbFN0YXRlOiBzdGF0ZSB9KSxcclxuXHJcbiAgc2V0QWRtaXNzaWJpbGl0eVZpb2xhdGlvbnM6IChpZHMpID0+IHNldCh7IGFkbWlzc2liaWxpdHlWaW9sYXRpb25zOiBpZHMgfSksXHJcblxyXG4gIHVwZGF0ZVRyZWU6IChuZXdUcmVlKSA9PiBzZXQoeyB0cmVlOiBuZXdUcmVlIH0pLFxyXG5cclxuICBhZGROb2RlOiAocGFyZW50SWQsIG5ld05vZGUpID0+IHNldCgoc3RhdGUpID0+IHtcclxuICAgIGNvbnN0IG5ld1RyZWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpKTtcclxuICAgIGNvbnN0IGFkZFJlY3Vyc2l2ZSA9IChub2RlOiBDdXN0b21UcmVlTm9kZSkgPT4ge1xyXG4gICAgICBpZiAobm9kZS5pZCA9PT0gcGFyZW50SWQpIHtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKGFkZFJlY3Vyc2l2ZShjaGlsZCkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBhZGRSZWN1cnNpdmUobmV3VHJlZSk7XHJcbiAgICByZXR1cm4geyB0cmVlOiBuZXdUcmVlIH07XHJcbiAgfSksXHJcblxyXG4gIHJlbW92ZU5vZGU6IChub2RlSWQpID0+IHNldCgoc3RhdGUpID0+IHtcclxuICAgIGlmIChub2RlSWQgPT09ICdyb290JykgcmV0dXJuIHN0YXRlO1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSkpO1xyXG4gICAgY29uc3QgcmVtb3ZlUmVjdXJzaXZlID0gKG5vZGU6IEN1c3RvbVRyZWVOb2RlKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gbm9kZS5jaGlsZHJlbi5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBub2RlSWQpO1xyXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChyZW1vdmVSZWN1cnNpdmUoY2hpbGQpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmVtb3ZlUmVjdXJzaXZlKG5ld1RyZWUpO1xyXG4gICAgcmV0dXJuIHsgdHJlZTogbmV3VHJlZSB9O1xyXG4gIH0pLFxyXG5cclxuICB1cGRhdGVOb2RlQXR0cmlidXRlczogKG5vZGVJZCwgYXR0cmlidXRlcykgPT4gc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgY29uc3QgbmV3VHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSkpO1xyXG4gICAgY29uc3QgdXBkYXRlUmVjdXJzaXZlID0gKG5vZGU6IEN1c3RvbVRyZWVOb2RlKSA9PiB7XHJcbiAgICAgIGlmIChub2RlLmlkID09PSBub2RlSWQpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIGlmICh1cGRhdGVSZWN1cnNpdmUoY2hpbGQpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgdXBkYXRlUmVjdXJzaXZlKG5ld1RyZWUpO1xyXG4gICAgcmV0dXJuIHsgdHJlZTogbmV3VHJlZSB9O1xyXG4gIH0pXHJcbn0pKVxyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwiaW5pdGlhbFRyZWUiLCJpZCIsIm5hbWUiLCJjaGlsZHJlbiIsInVzZUdhbWVTdG9yZSIsInNldCIsImFsZ29yaXRobSIsInByb2JsZW1UeXBlIiwiZGVwdGgiLCJub2Rlc0V4cGxvcmVkIiwiaXNTaW11bGF0aW5nIiwicmVzZXRUcmlnZ2VyIiwidHJlZSIsImFkbWlzc2liaWxpdHlWaW9sYXRpb25zIiwiZ29hbFN0YXRlIiwibWF4Tm9kZVNoYXBlIiwibWluTm9kZVNoYXBlIiwibm9kZVZpZXdNb2RlIiwic2V0QWxnb3JpdGhtIiwiYWxnbyIsInNldFByb2JsZW1UeXBlIiwidHlwZSIsInN0YXRlIiwibmV3Tm9kZVZpZXdNb2RlIiwibmV3VHJlZSIsIm5ld0dvYWxTdGF0ZSIsImJvYXJkU3RhdGUiLCJBcnJheSIsImZpbGwiLCJzZXREZXB0aCIsImluY3JlbWVudE5vZGVzIiwidG9nZ2xlU2ltdWxhdGlvbiIsInJlc2V0Iiwic2V0Tm9kZXNFeHBsb3JlZCIsImNvdW50Iiwic2V0TWF4Tm9kZVNoYXBlIiwic2hhcGUiLCJzZXRNaW5Ob2RlU2hhcGUiLCJzZXROb2RlVmlld01vZGUiLCJtb2RlIiwic2V0R29hbFN0YXRlIiwic2V0QWRtaXNzaWJpbGl0eVZpb2xhdGlvbnMiLCJpZHMiLCJ1cGRhdGVUcmVlIiwiYWRkTm9kZSIsInBhcmVudElkIiwibmV3Tm9kZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImFkZFJlY3Vyc2l2ZSIsIm5vZGUiLCJwdXNoIiwiY2hpbGQiLCJyZW1vdmVOb2RlIiwibm9kZUlkIiwicmVtb3ZlUmVjdXJzaXZlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJjIiwic3BsaWNlIiwidXBkYXRlTm9kZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwidXBkYXRlUmVjdXJzaXZlIiwiT2JqZWN0IiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/gameStore.ts\n"));

/***/ })

});